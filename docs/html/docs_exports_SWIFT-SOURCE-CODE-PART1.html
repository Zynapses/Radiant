<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SWIFT SOURCE CODE PART1 - RADIANT Documentation</title>
  
<style>
@media print {
  body { font-size: 11pt !important; }
  pre { page-break-inside: avoid; }
  h1, h2, h3 { page-break-after: avoid; }
  .no-print { display: none !important; }
}

* { box-sizing: border-box; }

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  line-height: 1.7;
  color: #1d1d1f;
  max-width: 900px;
  margin: 0 auto;
  padding: 40px 30px;
  background: white;
}

h1 {
  color: #1d1d1f;
  border-bottom: 3px solid #0071e3;
  padding-bottom: 12px;
  font-size: 28px;
  margin-top: 0;
}

h2 {
  color: #1d1d1f;
  border-bottom: 1px solid #d2d2d7;
  padding-bottom: 8px;
  font-size: 22px;
  margin-top: 40px;
}

h3 { color: #1d1d1f; font-size: 18px; margin-top: 30px; }
h4 { color: #1d1d1f; font-size: 16px; margin-top: 25px; }

a { color: #0071e3; text-decoration: none; }
a:hover { text-decoration: underline; }

code {
  background: #f5f5f7;
  padding: 2px 6px;
  border-radius: 4px;
  font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
  font-size: 0.9em;
  color: #1d1d1f;
}

pre {
  background: #1d1d1f;
  color: #f5f5f7;
  padding: 20px;
  border-radius: 10px;
  overflow-x: auto;
  font-size: 13px;
  line-height: 1.5;
}

pre code {
  background: transparent;
  padding: 0;
  color: inherit;
}

table {
  width: 100%;
  border-collapse: collapse;
  margin: 20px 0;
  font-size: 14px;
}

th, td {
  border: 1px solid #d2d2d7;
  padding: 12px 15px;
  text-align: left;
}

th {
  background: #0071e3;
  color: white;
  font-weight: 600;
}

tr:nth-child(even) { background: #f5f5f7; }

blockquote {
  border-left: 4px solid #0071e3;
  margin: 20px 0;
  padding: 15px 25px;
  background: #f5f5f7;
  border-radius: 0 8px 8px 0;
}

blockquote p { margin: 0; }

img { max-width: 100%; height: auto; border-radius: 8px; }

hr {
  border: none;
  border-top: 1px solid #d2d2d7;
  margin: 40px 0;
}

ul, ol { padding-left: 25px; }
li { margin: 8px 0; }

.header-bar {
  background: linear-gradient(135deg, #0071e3 0%, #00c6ff 100%);
  color: white;
  padding: 20px 30px;
  margin: -40px -30px 30px -30px;
  border-radius: 0 0 16px 16px;
}

.header-bar h1 {
  color: white;
  border: none;
  margin: 0;
  padding: 0;
}

.header-bar .meta {
  font-size: 13px;
  opacity: 0.9;
  margin-top: 8px;
}

.print-btn {
  position: fixed;
  top: 20px;
  right: 20px;
  background: #0071e3;
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  box-shadow: 0 4px 12px rgba(0,113,227,0.3);
}

.print-btn:hover { background: #0077ed; }

.mermaid {
  background: #f5f5f7;
  padding: 20px;
  border-radius: 10px;
  text-align: center;
  margin: 20px 0;
}

.footer {
  margin-top: 60px;
  padding-top: 20px;
  border-top: 1px solid #d2d2d7;
  color: #86868b;
  font-size: 12px;
  text-align: center;
}
</style>

</head>
<body>
  <button class="print-btn no-print" onclick="window.print()">üñ®Ô∏è Print / Save as PDF</button>
  
  <div class="header-bar">
    <h1>SWIFT SOURCE CODE PART1</h1>
    <div class="meta">RADIANT v5.52.29 | docs/exports/SWIFT-SOURCE-CODE-PART1.md</div>
  </div>
  
  <h1 id="radiant-swift-deployer---actual-source-code---part-1">RADIANT Swift Deployer - ACTUAL SOURCE CODE - Part 1</h1>
<h2 id="file-radiantdeployerapp.swift">File: RadiantDeployerApp.swift</h2>
<pre class="swift"><code>import SwiftUI

@main
struct RadiantDeployerApp: App {
    @StateObject private var appState = AppState()
    
    var body: some Scene {
        WindowGroup(&quot;Radiant Deployer&quot;) {
            MainView()
                .environmentObject(appState)
                .frame(minWidth: 1200, minHeight: 800)
        }
        .windowStyle(.titleBar)
        .windowToolbarStyle(.unified(showsTitle: true))
        .commands {
            RadiantCommands(appState: appState)
        }
        
        Settings {
            SettingsView()
                .environmentObject(appState)
        }
    }
}

#Preview {
    MainView()
        .environmentObject(AppState())
        .frame(width: 1200, height: 800)
}</code></pre>
<hr />
<h2 id="file-appstate.swift">File: AppState.swift</h2>
<pre class="swift"><code>import SwiftUI
import Combine

@MainActor
final class AppState: ObservableObject {
    // MARK: - Navigation
    @Published var selectedTab: NavigationTab = .dashboard
    @Published var selectedApp: ManagedApp?
    @Published var selectedEnvironment: DeployEnvironment = .dev
    
    // MARK: - UI State
    @Published var showInspector: Bool = false
    @Published var showAIAssistant: Bool = false
    @Published var sidebarWidth: CGFloat = 240
    @Published var inspectorWidth: CGFloat = 280
    @Published var columnVisibility: NavigationSplitViewVisibility = .all
    
    // MARK: - Data
    @Published var apps: [ManagedApp] = []
    @Published var credentials: [CredentialSet] = []
    @Published var isLoading = false
    @Published var error: AppError?
    
    // MARK: - Deployment
    @Published var isDeploying = false
    @Published var deploymentProgress: DeploymentProgress?
    @Published var deploymentLogs: [LogEntry] = []
    
    // MARK: - Services
    let credentialService = CredentialService()
    let cdkService = CDKService()
    let awsService = AWSService()
    let aiRegistryService = AIRegistryService()
    
    // MARK: - Radiant Connection
    @Published var radiantBaseURL: String?
    @Published var radiantAuthToken: String?
    @Published var isConnectedToRadiant = false
    
    // MARK: - 1Password Status
    @Published var onePasswordConfigured = true  // Start as true when bypassing
    @Published var onePasswordStatus: CredentialService.OnePasswordStatus?
    
    // MARK: - Debug/Testing
    @Published var bypassOnePassword = true  // Set to true to skip 1Password during testing
    
    // MARK: - Initialization
    init() {
        Task {
            await loadInitialData()
        }
    }
    
    func loadInitialData() async {
        isLoading = true
        defer { isLoading = false }
        
        // Allow bypass for testing
        if bypassOnePassword {
            onePasswordConfigured = true
            apps = ManagedApp.defaults
            return
        }
        
        // Check 1Password status first
        onePasswordStatus = await credentialService.checkOnePasswordStatus()
        onePasswordConfigured = onePasswordStatus?.installed == true &amp;&amp; onePasswordStatus?.signedIn == true
        
        guard onePasswordConfigured else {
            apps = ManagedApp.defaults
            return
        }
        
        do {
            credentials = try await credentialService.loadCredentials()
            apps = try await loadApps()
        } catch {
            self.error = AppError(message: &quot;Failed to load data&quot;, underlying: error)
        }
    }
    
    func refreshOnePasswordStatus() async {
        if bypassOnePassword {
            onePasswordConfigured = true
            return
        }
        
        onePasswordStatus = await credentialService.checkOnePasswordStatus()
        onePasswordConfigured = onePasswordStatus?.installed == true &amp;&amp; onePasswordStatus?.signedIn == true
        
        if onePasswordConfigured {
            do {
                credentials = try await credentialService.loadCredentials()
            } catch {
                self.error = AppError(message: &quot;Failed to load credentials&quot;, underlying: error)
            }
        }
    }
    
    private func loadApps() async throws -&gt; [ManagedApp] {
        return ManagedApp.defaults
    }
    
    // MARK: - Commands
    
    func refreshAllStatus() async {
        isLoading = true
        defer { isLoading = false }
        
        do {
            credentials = try await credentialService.loadCredentials()
            apps = try await loadApps()
        } catch {
            self.error = AppError(message: &quot;Failed to refresh status&quot;, underlying: error)
        }
    }
    
    func runHealthCheck() async {
        // Health check implementation
        isLoading = true
        defer { isLoading = false }
        
        // Check AWS connectivity and service health
        guard let credential = credentials.first else {
            isConnectedToRadiant = false
            return
        }
        
        let credentialsValid = await AWSService.shared.checkCredentialsValid(credential)
        let apiHealthy = await AWSService.shared.checkAPIHealth(credential: credential)
        let dbHealthy = await AWSService.shared.checkDatabaseHealth(credential: credential)
        
        // Update connection status based on health checks
        isConnectedToRadiant = credentialsValid &amp;&amp; apiHealthy &amp;&amp; dbHealthy
    }
}

// MARK: - Navigation
enum NavigationTab: String, CaseIterable, Identifiable, Sendable {
    // Main
    case dashboard = &quot;Dashboard&quot;
    case apps = &quot;Apps&quot;
    case deploy = &quot;Deploy&quot;
    
    // Operations
    case instances = &quot;Instances&quot;
    case snapshots = &quot;Snapshots&quot;
    case packages = &quot;Packages&quot;
    case history = &quot;History&quot;
    
    // AI Registry
    case providers = &quot;Providers&quot;
    case models = &quot;Models&quot;
    case selfHosted = &quot;Self-Hosted&quot;
    
    // Configuration
    case domains = &quot;Domains&quot;
    case email = &quot;Email&quot;
    
    // Advanced
    case multiRegion = &quot;Multi-Region&quot;
    case abTesting = &quot;A/B Testing&quot;
    
    // Security &amp; Compliance
    case security = &quot;Security&quot;
    case compliance = &quot;Compliance&quot;
    
    // System
    case costs = &quot;Costs&quot;
    case monitoring = &quot;Monitoring&quot;
    case settings = &quot;Settings&quot;
    
    var id: String { rawValue }
    
    var icon: String {
        switch self {
        case .dashboard: return &quot;square.grid.2x2&quot;
        case .apps: return &quot;app.badge&quot;
        case .deploy: return &quot;arrow.up.circle&quot;
        case .instances: return &quot;server.rack&quot;
        case .snapshots: return &quot;clock.arrow.circlepath&quot;
        case .packages: return &quot;shippingbox&quot;
        case .history: return &quot;clock&quot;
        case .providers: return &quot;building.2&quot;
        case .models: return &quot;cpu&quot;
        case .selfHosted: return &quot;memorychip&quot;
        case .domains: return &quot;globe.americas&quot;
        case .email: return &quot;envelope&quot;
        case .multiRegion: return &quot;globe&quot;
        case .abTesting: return &quot;flask&quot;
        case .security: return &quot;shield.lefthalf.filled&quot;
        case .compliance: return &quot;checkmark.shield&quot;
        case .costs: return &quot;dollarsign.circle&quot;
        case .monitoring: return &quot;waveform.path.ecg.rectangle&quot;
        case .settings: return &quot;gearshape&quot;
        }
    }
    
    var color: Color {
        switch self {
        case .dashboard: return .blue
        case .apps: return .purple
        case .deploy: return .green
        case .instances: return .orange
        case .snapshots: return .cyan
        case .packages: return .indigo
        case .history: return .brown
        case .providers: return .teal
        case .models: return .pink
        case .selfHosted: return .mint
        case .domains: return .cyan
        case .email: return .orange
        case .multiRegion: return .blue
        case .abTesting: return .purple
        case .security: return .red
        case .compliance: return .green
        case .costs: return .yellow
        case .monitoring: return .teal
        case .settings: return .gray
        }
    }
    
    static var mainTabs: [NavigationTab] {
        [.dashboard, .apps, .deploy]
    }
    
    static var operationTabs: [NavigationTab] {
        [.instances, .snapshots, .packages, .history]
    }
    
    static var aiTabs: [NavigationTab] {
        [.providers, .models, .selfHosted]
    }
    
    static var configTabs: [NavigationTab] {
        [.domains, .email]
    }
    
    static var advancedTabs: [NavigationTab] {
        [.multiRegion, .abTesting]
    }
    
    static var securityTabs: [NavigationTab] {
        [.security, .compliance]
    }
    
    static var systemTabs: [NavigationTab] {
        [.costs, .monitoring, .settings]
    }
}

// MARK: - DeployEnvironment
enum DeployEnvironment: String, CaseIterable, Identifiable, Sendable, Codable {
    case dev = &quot;Development&quot;
    case staging = &quot;Staging&quot;
    case prod = &quot;Production&quot;
    
    var id: String { rawValue }
    
    var shortName: String {
        switch self {
        case .dev: return &quot;DEV&quot;
        case .staging: return &quot;STAGING&quot;
        case .prod: return &quot;PROD&quot;
        }
    }
    
    var color: Color {
        switch self {
        case .dev: return .blue
        case .staging: return .orange
        case .prod: return .green
        }
    }
}

// MARK: - Error
struct AppError: Identifiable, Sendable {
    let id = UUID()
    let message: String
    let underlying: (any Error)?
    
    var localizedDescription: String {
        if let underlying = underlying {
            return &quot;\(message): \(underlying.localizedDescription)&quot;
        }
        return message
    }
}</code></pre>
<hr />
<h2 id="file-configradiantconfig.swift">File: Config/RadiantConfig.swift</h2>
<pre class="swift"><code>// RADIANT v4.18.0 - Configuration
// Centralized configuration with environment variable support

import Foundation
import os.log

// MARK: - Logger

enum RadiantLogger {
    private static let subsystem = &quot;com.radiant.deployer&quot;
    
    static let general = Logger(subsystem: subsystem, category: &quot;general&quot;)
    static let deployment = Logger(subsystem: subsystem, category: &quot;deployment&quot;)
    static let packages = Logger(subsystem: subsystem, category: &quot;packages&quot;)
    static let seeds = Logger(subsystem: subsystem, category: &quot;seeds&quot;)
    static let aws = Logger(subsystem: subsystem, category: &quot;aws&quot;)
    static let credentials = Logger(subsystem: subsystem, category: &quot;credentials&quot;)
    
    /// Log an error with context
    static func error(_ message: String, error: Error? = nil, category: Logger = general) {
        if let error = error {
            category.error(&quot;\(message): \(error.localizedDescription)&quot;)
        } else {
            category.error(&quot;\(message)&quot;)
        }
    }
    
    /// Log a warning
    static func warning(_ message: String, category: Logger = general) {
        category.warning(&quot;\(message)&quot;)
    }
    
    /// Log info
    static func info(_ message: String, category: Logger = general) {
        category.info(&quot;\(message)&quot;)
    }
    
    /// Log debug info
    static func debug(_ message: String, category: Logger = general) {
        category.debug(&quot;\(message)&quot;)
    }
}

// MARK: - Configuration

struct RadiantConfig: Sendable {
    
    // MARK: - Singleton
    
    static let shared = RadiantConfig()
    
    // MARK: - AWS Configuration
    
    /// S3 bucket for official releases
    let releasesBucket: String
    
    /// S3 bucket prefix for seeds
    let seedsPrefix: String
    
    /// S3 bucket prefix for packages
    let packagesPrefix: String
    
    /// Default AWS region
    let defaultRegion: String
    
    // MARK: - Paths
    
    /// Local cache directory for packages
    let packageCacheDirectory: URL
    
    /// Local cache directory for seeds
    let seedsCacheDirectory: URL
    
    /// AWS CLI path
    let awsCliPath: String
    
    /// CDK CLI path
    let cdkCliPath: String
    
    // MARK: - Timeouts
    
    /// Default network timeout in seconds
    let networkTimeout: TimeInterval
    
    /// CDK deployment timeout in seconds
    let cdkDeploymentTimeout: TimeInterval
    
    /// Health check timeout in seconds
    let healthCheckTimeout: TimeInterval
    
    // MARK: - Feature Flags
    
    /// Enable verbose logging
    let verboseLogging: Bool
    
    /// Enable dry run mode (no actual deployments)
    let dryRunMode: Bool
    
    // MARK: - Initialization
    
    private init() {
        let env = ProcessInfo.processInfo.environment
        
        // AWS Configuration
        self.releasesBucket = env[&quot;RADIANT_RELEASES_BUCKET&quot;] ?? &quot;radiant-releases-us-east-1&quot;
        self.seedsPrefix = env[&quot;RADIANT_SEEDS_PREFIX&quot;] ?? &quot;seeds/&quot;
        self.packagesPrefix = env[&quot;RADIANT_PACKAGES_PREFIX&quot;] ?? &quot;packages/&quot;
        self.defaultRegion = env[&quot;AWS_DEFAULT_REGION&quot;] ?? &quot;us-east-1&quot;
        
        // Paths - safely unwrap application support directory
        let appSupport: URL
        if let appSupportDir = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first {
            appSupport = appSupportDir
        } else {
            // Fallback to home directory if application support is unavailable
            appSupport = FileManager.default.homeDirectoryForCurrentUser.appendingPathComponent(&quot;Library/Application Support&quot;)
        }
        let radiantDir = appSupport.appendingPathComponent(&quot;RadiantDeployer&quot;)
        
        self.packageCacheDirectory = radiantDir.appendingPathComponent(&quot;packages&quot;)
        self.seedsCacheDirectory = radiantDir.appendingPathComponent(&quot;seeds&quot;)
        self.awsCliPath = env[&quot;AWS_CLI_PATH&quot;] ?? &quot;/usr/local/bin/aws&quot;
        self.cdkCliPath = env[&quot;CDK_CLI_PATH&quot;] ?? &quot;/usr/local/bin/cdk&quot;
        
        // Timeouts
        self.networkTimeout = TimeInterval(env[&quot;RADIANT_NETWORK_TIMEOUT&quot;] ?? &quot;30&quot;) ?? 30
        self.cdkDeploymentTimeout = TimeInterval(env[&quot;RADIANT_CDK_TIMEOUT&quot;] ?? &quot;3600&quot;) ?? 3600
        self.healthCheckTimeout = TimeInterval(env[&quot;RADIANT_HEALTH_TIMEOUT&quot;] ?? &quot;60&quot;) ?? 60
        
        // Feature Flags
        self.verboseLogging = env[&quot;RADIANT_VERBOSE&quot;] == &quot;true&quot;
        self.dryRunMode = env[&quot;RADIANT_DRY_RUN&quot;] == &quot;true&quot;
        
        // Ensure cache directories exist
        try? FileManager.default.createDirectory(at: packageCacheDirectory, withIntermediateDirectories: true)
        try? FileManager.default.createDirectory(at: seedsCacheDirectory, withIntermediateDirectories: true)
    }
    
    // MARK: - Helpers
    
    /// Get the full S3 URI for releases bucket
    func releasesS3URI(path: String = &quot;&quot;) -&gt; String {
        &quot;s3://\(releasesBucket)/\(path)&quot;
    }
    
    /// Get environment-specific bucket name
    func instanceBucket(appId: String, environment: String) -&gt; String {
        &quot;radiant-\(appId)-\(environment)-deployments&quot;
    }
}

// MARK: - Credential Sanitization

extension RadiantConfig {
    
    /// Sanitize a string to remove potential credentials
    static func sanitize(_ string: String) -&gt; String {
        var result = string
        
        // Patterns that might contain credentials
        let patterns = [
            // AWS Access Key ID (starts with AKIA, ABIA, ACCA, ASIA)
            &quot;A[KBS]IA[A-Z0-9]{16}&quot;,
            // AWS Secret Access Key (40 char base64)
            &quot;[A-Za-z0-9/+=]{40}&quot;,
            // Generic API keys
            &quot;(?i)(api[_-]?key|apikey|secret|password|token)[\&quot;&#39;:\\s=]+[A-Za-z0-9/+=_-]{16,}&quot;,
        ]
        
        for pattern in patterns {
            if let regex = try? NSRegularExpression(pattern: pattern, options: []) {
                result = regex.stringByReplacingMatches(
                    in: result,
                    range: NSRange(result.startIndex..., in: result),
                    withTemplate: &quot;[REDACTED]&quot;
                )
            }
        }
        
        return result
    }
    
    /// Sanitize error for logging (removes potential credentials)
    static func sanitizeError(_ error: Error) -&gt; String {
        sanitize(error.localizedDescription)
    }
}</code></pre>
<hr />
<h2 id="file-modelsdeployment.swift">File: Models/Deployment.swift</h2>
<pre class="swift"><code>import Foundation

let RADIANT_VERSION = &quot;4.18.0&quot;

struct DeploymentProgress: Identifiable, Sendable {
    let id = UUID()
    var phase: DeploymentPhase
    var progress: Double
    var currentStack: String?
    var message: String?
    var startedAt: Date
    var estimatedCompletion: Date?
}

enum DeploymentPhase: String, CaseIterable, Sendable {
    case idle = &quot;Idle&quot;
    case validating = &quot;Validating Credentials&quot;
    case bootstrapping = &quot;Bootstrapping CDK&quot;
    case synthesizing = &quot;Synthesizing Stacks&quot;
    case deployingFoundation = &quot;Deploying Foundation&quot;
    case deployingNetworking = &quot;Deploying Networking&quot;
    case deploySecurity = &quot;Deploying Security&quot;
    case deployingData = &quot;Deploying Data Layer&quot;
    case deployingAI = &quot;Deploying AI Services&quot;
    case deployingAPI = &quot;Deploying API Layer&quot;
    case deployingAdmin = &quot;Deploying Admin Dashboard&quot;
    case runningMigrations = &quot;Running Migrations&quot;
    case seedingData = &quot;Seeding Initial Data&quot;
    case verifying = &quot;Verifying Deployment&quot;
    case complete = &quot;Complete&quot;
    case failed = &quot;Failed&quot;
    
    var progress: Double {
        switch self {
        case .idle: return 0.0
        case .validating: return 0.05
        case .bootstrapping: return 0.10
        case .synthesizing: return 0.15
        case .deployingFoundation: return 0.25
        case .deployingNetworking: return 0.35
        case .deploySecurity: return 0.45
        case .deployingData: return 0.55
        case .deployingAI: return 0.65
        case .deployingAPI: return 0.75
        case .deployingAdmin: return 0.85
        case .runningMigrations: return 0.90
        case .seedingData: return 0.95
        case .verifying: return 0.98
        case .complete: return 1.0
        case .failed: return 0.0
        }
    }
    
    var icon: String {
        switch self {
        case .idle: return &quot;circle&quot;
        case .validating: return &quot;checkmark.shield&quot;
        case .bootstrapping: return &quot;arrow.up.circle&quot;
        case .synthesizing: return &quot;doc.text&quot;
        case .deployingFoundation: return &quot;building&quot;
        case .deployingNetworking: return &quot;network&quot;
        case .deploySecurity: return &quot;lock.shield&quot;
        case .deployingData: return &quot;cylinder&quot;
        case .deployingAI: return &quot;cpu&quot;
        case .deployingAPI: return &quot;server.rack&quot;
        case .deployingAdmin: return &quot;rectangle.3.group&quot;
        case .runningMigrations: return &quot;arrow.triangle.2.circlepath&quot;
        case .seedingData: return &quot;leaf&quot;
        case .verifying: return &quot;checkmark.circle&quot;
        case .complete: return &quot;checkmark.circle.fill&quot;
        case .failed: return &quot;xmark.circle.fill&quot;
        }
    }
}

struct DeploymentResult: Identifiable, Codable, Sendable {
    let id: String
    let appId: String
    let environment: String
    let version: String
    let success: Bool
    let startedAt: Date
    let completedAt: Date
    let outputs: DeploymentOutputs?
    let errors: [String]?
    
    static func create(
        appId: String,
        environment: String,
        success: Bool,
        startedAt: Date,
        outputs: DeploymentOutputs? = nil,
        errors: [String]? = nil
    ) -&gt; DeploymentResult {
        DeploymentResult(
            id: UUID().uuidString,
            appId: appId,
            environment: environment,
            version: RADIANT_VERSION,
            success: success,
            startedAt: startedAt,
            completedAt: Date(),
            outputs: outputs,
            errors: errors
        )
    }
}

struct DeploymentOutputs: Codable, Sendable {
    let apiUrl: String
    let graphqlUrl: String
    let dashboardUrl: String
    let cognitoUserPoolId: String
    let cognitoClientId: String
    let cognitoDomain: String
    let auroraEndpoint: String
    let s3MediaBucket: String
    let cloudfrontDistribution: String
}

struct LogEntry: Identifiable, Sendable {
    let id = UUID()
    let timestamp: Date
    let level: LogLevel
    let message: String
    let metadata: [String: String]?
}

enum LogLevel: String, Sendable, Codable {
    case debug, info, warn, error, success
    
    var color: String {
        switch self {
        case .debug: return &quot;gray&quot;
        case .info: return &quot;blue&quot;
        case .warn: return &quot;orange&quot;
        case .error: return &quot;red&quot;
        case .success: return &quot;green&quot;
        }
    }
    
    var icon: String {
        switch self {
        case .debug: return &quot;ant&quot;
        case .info: return &quot;info.circle&quot;
        case .warn: return &quot;exclamationmark.triangle&quot;
        case .error: return &quot;xmark.circle&quot;
        case .success: return &quot;checkmark.circle&quot;
        }
    }
}

// MARK: - PROMPT-33 Granular Deployment State

/// Preparation steps before deployment
enum PreparationStep: String, Sendable {
    case validatingPackage = &quot;Validating Package&quot;
    case checkingCompatibility = &quot;Checking Compatibility&quot;
    case acquiringLock = &quot;Acquiring Deployment Lock&quot;
    case loadingConfiguration = &quot;Loading Configuration&quot;
}

/// Health check result for individual service
struct HealthCheckResult: Sendable, Identifiable {
    let id = UUID()
    let service: String
    let status: HealthStatus
    let responseTime: TimeInterval?
    let message: String?
    
    enum HealthStatus: String, Sendable {
        case healthy = &quot;Healthy&quot;
        case unhealthy = &quot;Unhealthy&quot;
        case timeout = &quot;Timeout&quot;
        case pending = &quot;Pending&quot;
    }
}

/// Deployment failure details
struct DeploymentFailure: Sendable {
    let phase: String
    let error: String
    let technicalDetails: String?
    let isRetryable: Bool
    let timestamp: Date
    
    init(phase: String, error: Error, isRetryable: Bool = false) {
        self.phase = phase
        self.error = error.localizedDescription
        self.technicalDetails = String(describing: error)
        self.isRetryable = isRetryable
        self.timestamp = Date()
    }
}

/// Rollback result after recovery
struct RollbackResult: Sendable {
    let success: Bool
    let snapshotId: String?
    let restoredVersion: String?
    let duration: TimeInterval
    let message: String
}

/// Rollback failure details
struct RollbackFailure: Sendable {
    let error: String
    let partiallyRestored: Bool
    let recoverySteps: [String]
}

/// Granular deployment state per PROMPT-33 spec
enum DeploymentState: Sendable {
    case idle
    case preparing(PreparationStep)
    case creatingSnapshot(progress: Double)
    case enablingMaintenance
    case deployingInfrastructure(progress: Double, message: String)
    case runningMigrations(current: Int, total: Int, stepName: String)
    case deployingLambda(progress: Double)
    case deployingDashboard(progress: Double)
    case runningHealthChecks(results: [HealthCheckResult])
    case disablingMaintenance
    case verifying
    case complete(DeploymentResult)
    case failed(DeploymentFailure)
    case cancelling(fromState: String)
    case rollingBack(progress: Double, step: String)
    case rolledBack(RollbackResult)
    case rollbackFailed(RollbackFailure)
    
    /// Whether cancel is allowed in this state
    var canCancel: Bool {
        switch self {
        case .idle, .complete, .failed, .cancelling, .rollingBack, .rolledBack, .rollbackFailed:
            return false
        case .preparing, .creatingSnapshot, .enablingMaintenance, .deployingInfrastructure,
             .runningMigrations, .deployingLambda, .deployingDashboard, .runningHealthChecks,
             .disablingMaintenance, .verifying:
            return true
        }
    }
    
    /// Overall progress percentage
    var progress: Double {
        switch self {
        case .idle: return 0.0
        case .preparing: return 0.05
        case .creatingSnapshot(let p): return 0.05 + p * 0.10
        case .enablingMaintenance: return 0.15
        case .deployingInfrastructure(let p, _): return 0.15 + p * 0.40
        case .runningMigrations(let c, let t, _): return 0.55 + (Double(c) / Double(max(t, 1))) * 0.15
        case .deployingLambda(let p): return 0.70 + p * 0.10
        case .deployingDashboard(let p): return 0.80 + p * 0.10
        case .runningHealthChecks: return 0.90
        case .disablingMaintenance: return 0.95
        case .verifying: return 0.98
        case .complete: return 1.0
        case .failed: return 0.0
        case .cancelling: return 0.0
        case .rollingBack(let p, _): return p
        case .rolledBack: return 1.0
        case .rollbackFailed: return 0.0
        }
    }
    
    /// Display name for the state
    var displayName: String {
        switch self {
        case .idle: return &quot;Ready&quot;
        case .preparing(let step): return step.rawValue
        case .creatingSnapshot: return &quot;Creating Snapshot&quot;
        case .enablingMaintenance: return &quot;Enabling Maintenance Mode&quot;
        case .deployingInfrastructure(_, let msg): return msg.isEmpty ? &quot;Deploying Infrastructure&quot; : msg
        case .runningMigrations(let c, let t, let name): return &quot;Migration \(c)/\(t): \(name)&quot;
        case .deployingLambda: return &quot;Deploying Lambda Functions&quot;
        case .deployingDashboard: return &quot;Deploying Admin Dashboard&quot;
        case .runningHealthChecks: return &quot;Running Health Checks&quot;
        case .disablingMaintenance: return &quot;Disabling Maintenance Mode&quot;
        case .verifying: return &quot;Verifying Deployment&quot;
        case .complete: return &quot;Deployment Complete&quot;
        case .failed(let f): return &quot;Failed: \(f.phase)&quot;
        case .cancelling(let from): return &quot;Cancelling (\(from))&quot;
        case .rollingBack(_, let step): return &quot;Rolling Back: \(step)&quot;
        case .rolledBack: return &quot;Rolled Back Successfully&quot;
        case .rollbackFailed: return &quot;Rollback Failed&quot;
        }
    }
    
    /// Icon for the state
    var icon: String {
        switch self {
        case .idle: return &quot;circle&quot;
        case .preparing: return &quot;gearshape&quot;
        case .creatingSnapshot: return &quot;camera&quot;
        case .enablingMaintenance: return &quot;wrench.and.screwdriver&quot;
        case .deployingInfrastructure: return &quot;building.2&quot;
        case .runningMigrations: return &quot;arrow.triangle.2.circlepath&quot;
        case .deployingLambda: return &quot;function&quot;
        case .deployingDashboard: return &quot;rectangle.3.group&quot;
        case .runningHealthChecks: return &quot;heart.text.square&quot;
        case .disablingMaintenance: return &quot;checkmark.seal&quot;
        case .verifying: return &quot;checkmark.shield&quot;
        case .complete: return &quot;checkmark.circle.fill&quot;
        case .failed: return &quot;xmark.circle.fill&quot;
        case .cancelling: return &quot;stop.circle&quot;
        case .rollingBack: return &quot;arrow.uturn.backward.circle&quot;
        case .rolledBack: return &quot;arrow.uturn.backward.circle.fill&quot;
        case .rollbackFailed: return &quot;exclamationmark.triangle.fill&quot;
        }
    }
    
    /// Whether this is a terminal state
    var isTerminal: Bool {
        switch self {
        case .complete, .failed, .rolledBack, .rollbackFailed:
            return true
        default:
            return false
        }
    }
}</code></pre>

  
  <div class="footer">
    RADIANT Documentation | Version 5.52.29 | Generated January 25, 2026
  </div>
</body>
</html>