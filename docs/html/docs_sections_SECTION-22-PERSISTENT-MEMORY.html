<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SECTION 22 PERSISTENT MEMORY - RADIANT Documentation</title>
  
<style>
@media print {
  body { font-size: 11pt !important; }
  pre { page-break-inside: avoid; }
  h1, h2, h3 { page-break-after: avoid; }
  .no-print { display: none !important; }
}

* { box-sizing: border-box; }

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  line-height: 1.7;
  color: #1d1d1f;
  max-width: 900px;
  margin: 0 auto;
  padding: 40px 30px;
  background: white;
}

h1 {
  color: #1d1d1f;
  border-bottom: 3px solid #0071e3;
  padding-bottom: 12px;
  font-size: 28px;
  margin-top: 0;
}

h2 {
  color: #1d1d1f;
  border-bottom: 1px solid #d2d2d7;
  padding-bottom: 8px;
  font-size: 22px;
  margin-top: 40px;
}

h3 { color: #1d1d1f; font-size: 18px; margin-top: 30px; }
h4 { color: #1d1d1f; font-size: 16px; margin-top: 25px; }

a { color: #0071e3; text-decoration: none; }
a:hover { text-decoration: underline; }

code {
  background: #f5f5f7;
  padding: 2px 6px;
  border-radius: 4px;
  font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
  font-size: 0.9em;
  color: #1d1d1f;
}

pre {
  background: #1d1d1f;
  color: #f5f5f7;
  padding: 20px;
  border-radius: 10px;
  overflow-x: auto;
  font-size: 13px;
  line-height: 1.5;
}

pre code {
  background: transparent;
  padding: 0;
  color: inherit;
}

table {
  width: 100%;
  border-collapse: collapse;
  margin: 20px 0;
  font-size: 14px;
}

th, td {
  border: 1px solid #d2d2d7;
  padding: 12px 15px;
  text-align: left;
}

th {
  background: #0071e3;
  color: white;
  font-weight: 600;
}

tr:nth-child(even) { background: #f5f5f7; }

blockquote {
  border-left: 4px solid #0071e3;
  margin: 20px 0;
  padding: 15px 25px;
  background: #f5f5f7;
  border-radius: 0 8px 8px 0;
}

blockquote p { margin: 0; }

img { max-width: 100%; height: auto; border-radius: 8px; }

hr {
  border: none;
  border-top: 1px solid #d2d2d7;
  margin: 40px 0;
}

ul, ol { padding-left: 25px; }
li { margin: 8px 0; }

.header-bar {
  background: linear-gradient(135deg, #0071e3 0%, #00c6ff 100%);
  color: white;
  padding: 20px 30px;
  margin: -40px -30px 30px -30px;
  border-radius: 0 0 16px 16px;
}

.header-bar h1 {
  color: white;
  border: none;
  margin: 0;
  padding: 0;
}

.header-bar .meta {
  font-size: 13px;
  opacity: 0.9;
  margin-top: 8px;
}

.print-btn {
  position: fixed;
  top: 20px;
  right: 20px;
  background: #0071e3;
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  box-shadow: 0 4px 12px rgba(0,113,227,0.3);
}

.print-btn:hover { background: #0077ed; }

.mermaid {
  background: #f5f5f7;
  padding: 20px;
  border-radius: 10px;
  text-align: center;
  margin: 20px 0;
}

.footer {
  margin-top: 60px;
  padding-top: 20px;
  border-top: 1px solid #d2d2d7;
  color: #86868b;
  font-size: 12px;
  text-align: center;
}
</style>

</head>
<body>
  <button class="print-btn no-print" onclick="window.print()">üñ®Ô∏è Print / Save as PDF</button>
  
  <div class="header-bar">
    <h1>SECTION 22 PERSISTENT MEMORY</h1>
    <div class="meta">RADIANT v5.52.29 | docs/sections/SECTION-22-PERSISTENT-MEMORY.md</div>
  </div>
  
  <h1 id="section-22-persistent-memory-v3.6.0">SECTION 22: PERSISTENT MEMORY (v3.6.0)</h1>
<h1 id="section">‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê</h1>
<h2 id="memory-system-overview">22.1 Memory System Overview</h2>
<p>Long-term memory storage using pgvector embeddings for semantic search.</p>
<h2 id="memory-database-schema">22.2 Memory Database Schema</h2>
<pre class="sql"><code>-- migrations/031_persistent_memory.sql

CREATE TABLE memory_stores (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES tenants(id),
    user_id UUID NOT NULL REFERENCES users(id),
    store_name VARCHAR(100) NOT NULL DEFAULT &#39;default&#39;,
    embedding_model VARCHAR(100) DEFAULT &#39;text-embedding-3-small&#39;,
    total_memories INTEGER DEFAULT 0,
    last_accessed TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(tenant_id, user_id, store_name)
);

CREATE TABLE memories (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    store_id UUID NOT NULL REFERENCES memory_stores(id) ON DELETE CASCADE,
    content TEXT NOT NULL,
    embedding vector(1536),
    memory_type VARCHAR(50) DEFAULT &#39;fact&#39;,
    source VARCHAR(100),
    importance DECIMAL(3, 2) DEFAULT 0.5,
    access_count INTEGER DEFAULT 0,
    last_accessed TIMESTAMPTZ,
    expires_at TIMESTAMPTZ,
    metadata JSONB DEFAULT &#39;{}&#39;,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE memory_relationships (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    source_memory_id UUID NOT NULL REFERENCES memories(id) ON DELETE CASCADE,
    target_memory_id UUID NOT NULL REFERENCES memories(id) ON DELETE CASCADE,
    relationship_type VARCHAR(50) NOT NULL,
    strength DECIMAL(3, 2) DEFAULT 0.5,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(source_memory_id, target_memory_id, relationship_type)
);

CREATE INDEX idx_memories_embedding ON memories USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);
CREATE INDEX idx_memories_store ON memories(store_id);
CREATE INDEX idx_memory_relationships ON memory_relationships(source_memory_id);

ALTER TABLE memory_stores ENABLE ROW LEVEL SECURITY;
ALTER TABLE memories ENABLE ROW LEVEL SECURITY;
ALTER TABLE memory_relationships ENABLE ROW LEVEL SECURITY;

CREATE POLICY memory_stores_isolation ON memory_stores USING (tenant_id = current_setting(&#39;app.current_tenant_id&#39;)::UUID);
CREATE POLICY memories_isolation ON memories USING (
    store_id IN (SELECT id FROM memory_stores WHERE tenant_id = current_setting(&#39;app.current_tenant_id&#39;)::UUID)
);
CREATE POLICY memory_relationships_isolation ON memory_relationships USING (
    source_memory_id IN (SELECT m.id FROM memories m JOIN memory_stores ms ON m.store_id = ms.id WHERE ms.tenant_id = current_setting(&#39;app.current_tenant_id&#39;)::UUID)
);</code></pre>
<h2 id="memory-service">22.3 Memory Service</h2>
<pre class="typescript"><code>// packages/core/src/services/memory-service.ts

import { Pool } from &#39;pg&#39;;
import { BedrockRuntimeClient, InvokeModelCommand } from &#39;@aws-sdk/client-bedrock-runtime&#39;;

export class MemoryService {
    private pool: Pool;
    private bedrock: BedrockRuntimeClient;
    
    constructor(pool: Pool) {
        this.pool = pool;
        this.bedrock = new BedrockRuntimeClient({});
    }
    
    async getOrCreateStore(tenantId: string, userId: string, storeName: string = &#39;default&#39;): Promise&lt;string&gt; {
        const result = await this.pool.query(`
            INSERT INTO memory_stores (tenant_id, user_id, store_name)
            VALUES ($1, $2, $3)
            ON CONFLICT (tenant_id, user_id, store_name) DO UPDATE SET last_accessed = NOW()
            RETURNING id
        `, [tenantId, userId, storeName]);
        
        return result.rows[0].id;
    }
    
    async addMemory(
        storeId: string,
        content: string,
        options?: {
            type?: string;
            source?: string;
            importance?: number;
            metadata?: Record&lt;string, any&gt;;
        }
    ): Promise&lt;string&gt; {
        const embedding = await this.generateEmbedding(content);
        
        const result = await this.pool.query(`
            INSERT INTO memories (store_id, content, embedding, memory_type, source, importance, metadata)
            VALUES ($1, $2, $3::vector, $4, $5, $6, $7)
            RETURNING id
        `, [
            storeId,
            content,
            `[${embedding.join(&#39;,&#39;)}]`,
            options?.type || &#39;fact&#39;,
            options?.source,
            options?.importance || 0.5,
            JSON.stringify(options?.metadata || {})
        ]);
        
        // Update store count
        await this.pool.query(`
            UPDATE memory_stores SET total_memories = total_memories + 1 WHERE id = $1
        `, [storeId]);
        
        return result.rows[0].id;
    }
    
    async searchMemories(
        storeId: string,
        query: string,
        limit: number = 5,
        minSimilarity: number = 0.7
    ): Promise&lt;any[]&gt; {
        const embedding = await this.generateEmbedding(query);
        
        const result = await this.pool.query(`
            SELECT 
                id, content, memory_type, source, importance, metadata,
                1 - (embedding &lt;=&gt; $2::vector) as similarity
            FROM memories
            WHERE store_id = $1
            AND (expires_at IS NULL OR expires_at &gt; NOW())
            AND 1 - (embedding &lt;=&gt; $2::vector) &gt;= $4
            ORDER BY embedding &lt;=&gt; $2::vector
            LIMIT $3
        `, [storeId, `[${embedding.join(&#39;,&#39;)}]`, limit, minSimilarity]);
        
        // Update access counts
        const memoryIds = result.rows.map(r =&gt; r.id);
        if (memoryIds.length &gt; 0) {
            await this.pool.query(`
                UPDATE memories SET access_count = access_count + 1, last_accessed = NOW()
                WHERE id = ANY($1)
            `, [memoryIds]);
        }
        
        return result.rows;
    }
    
    async addRelationship(
        sourceId: string,
        targetId: string,
        relationshipType: string,
        strength: number = 0.5
    ): Promise&lt;void&gt; {
        await this.pool.query(`
            INSERT INTO memory_relationships (source_memory_id, target_memory_id, relationship_type, strength)
            VALUES ($1, $2, $3, $4)
            ON CONFLICT (source_memory_id, target_memory_id, relationship_type)
            DO UPDATE SET strength = EXCLUDED.strength
        `, [sourceId, targetId, relationshipType, strength]);
    }
    
    async getRelatedMemories(memoryId: string, limit: number = 5): Promise&lt;any[]&gt; {
        const result = await this.pool.query(`
            SELECT m.*, mr.relationship_type, mr.strength
            FROM memory_relationships mr
            JOIN memories m ON mr.target_memory_id = m.id
            WHERE mr.source_memory_id = $1
            ORDER BY mr.strength DESC
            LIMIT $2
        `, [memoryId, limit]);
        
        return result.rows;
    }
    
    private async generateEmbedding(text: string): Promise&lt;number[]&gt; {
        const response = await this.bedrock.send(new InvokeModelCommand({
            modelId: &#39;amazon.titan-embed-text-v1&#39;,
            body: JSON.stringify({ inputText: text }),
            contentType: &#39;application/json&#39;
        }));
        
        const result = JSON.parse(new TextDecoder().decode(response.body));
        return result.embedding;
    }
}</code></pre>
<h1 id="section-1">‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê</h1>

  
  <div class="footer">
    RADIANT Documentation | Version 5.52.29 | Generated January 25, 2026
  </div>
</body>
</html>