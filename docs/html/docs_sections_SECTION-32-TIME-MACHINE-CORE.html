<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SECTION 32 TIME MACHINE CORE - RADIANT Documentation</title>
  
<style>
@media print {
  body { font-size: 11pt !important; }
  pre { page-break-inside: avoid; }
  h1, h2, h3 { page-break-after: avoid; }
  .no-print { display: none !important; }
}

* { box-sizing: border-box; }

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  line-height: 1.7;
  color: #1d1d1f;
  max-width: 900px;
  margin: 0 auto;
  padding: 40px 30px;
  background: white;
}

h1 {
  color: #1d1d1f;
  border-bottom: 3px solid #0071e3;
  padding-bottom: 12px;
  font-size: 28px;
  margin-top: 0;
}

h2 {
  color: #1d1d1f;
  border-bottom: 1px solid #d2d2d7;
  padding-bottom: 8px;
  font-size: 22px;
  margin-top: 40px;
}

h3 { color: #1d1d1f; font-size: 18px; margin-top: 30px; }
h4 { color: #1d1d1f; font-size: 16px; margin-top: 25px; }

a { color: #0071e3; text-decoration: none; }
a:hover { text-decoration: underline; }

code {
  background: #f5f5f7;
  padding: 2px 6px;
  border-radius: 4px;
  font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
  font-size: 0.9em;
  color: #1d1d1f;
}

pre {
  background: #1d1d1f;
  color: #f5f5f7;
  padding: 20px;
  border-radius: 10px;
  overflow-x: auto;
  font-size: 13px;
  line-height: 1.5;
}

pre code {
  background: transparent;
  padding: 0;
  color: inherit;
}

table {
  width: 100%;
  border-collapse: collapse;
  margin: 20px 0;
  font-size: 14px;
}

th, td {
  border: 1px solid #d2d2d7;
  padding: 12px 15px;
  text-align: left;
}

th {
  background: #0071e3;
  color: white;
  font-weight: 600;
}

tr:nth-child(even) { background: #f5f5f7; }

blockquote {
  border-left: 4px solid #0071e3;
  margin: 20px 0;
  padding: 15px 25px;
  background: #f5f5f7;
  border-radius: 0 8px 8px 0;
}

blockquote p { margin: 0; }

img { max-width: 100%; height: auto; border-radius: 8px; }

hr {
  border: none;
  border-top: 1px solid #d2d2d7;
  margin: 40px 0;
}

ul, ol { padding-left: 25px; }
li { margin: 8px 0; }

.header-bar {
  background: linear-gradient(135deg, #0071e3 0%, #00c6ff 100%);
  color: white;
  padding: 20px 30px;
  margin: -40px -30px 30px -30px;
  border-radius: 0 0 16px 16px;
}

.header-bar h1 {
  color: white;
  border: none;
  margin: 0;
  padding: 0;
}

.header-bar .meta {
  font-size: 13px;
  opacity: 0.9;
  margin-top: 8px;
}

.print-btn {
  position: fixed;
  top: 20px;
  right: 20px;
  background: #0071e3;
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  box-shadow: 0 4px 12px rgba(0,113,227,0.3);
}

.print-btn:hover { background: #0077ed; }

.mermaid {
  background: #f5f5f7;
  padding: 20px;
  border-radius: 10px;
  text-align: center;
  margin: 20px 0;
}

.footer {
  margin-top: 60px;
  padding-top: 20px;
  border-top: 1px solid #d2d2d7;
  color: #86868b;
  font-size: 12px;
  text-align: center;
}
</style>

</head>
<body>
  <button class="print-btn no-print" onclick="window.print()">ğŸ–¨ï¸ Print / Save as PDF</button>
  
  <div class="header-bar">
    <h1>SECTION 32 TIME MACHINE CORE</h1>
    <div class="meta">RADIANT v5.52.29 | docs/sections/SECTION-32-TIME-MACHINE-CORE.md</div>
  </div>
  
  <h1 id="section-32-time-machine-core---database-service-layer-v4.0.0">SECTION 32: TIME MACHINE CORE - DATABASE &amp; SERVICE LAYER (v4.0.0)</h1>
<h1 id="section">â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</h1>
<blockquote>
<p><strong>Version: 4.0.0 | Apple Time Machine-inspired chat history for Think Tank</strong> <strong>NEVER lose a chat or file - everything is preserved and recoverable forever</strong></p>
</blockquote>
<hr />
<h2 id="time-machine-design-philosophy">32.1 Time Machine Design Philosophy</h2>
<h3 id="inspired-by-apple-time-machines-best-parts">Inspired by Apple Time Machineâ€™s Best Parts</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    APPLE TIME MACHINE INSPIRATION                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  WHAT WE&#39;RE BORROWING:                                                      â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                    â”‚
â”‚  1. Visual &quot;fly back through time&quot; - messages recede into the past         â”‚
â”‚  2. Calendar-based navigation - pick any date to jump to                   â”‚
â”‚  3. Timeline bar on the side - scrub to any point                          â”‚
â”‚  4. One-click restore - instantly recover anything                         â”‚
â”‚  5. &quot;Enter Time Machine&quot; mode - separate from normal view                  â”‚
â”‚  6. Everything is automatic - no manual &quot;save&quot; needed                      â”‚
â”‚  7. Never delete anything - space is cheap, data is priceless             â”‚
â”‚                                                                             â”‚
â”‚  RADIANT IMPROVEMENTS:                                                      â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                      â”‚
â”‚  1. Works for chat AND files (unified versioning)                          â”‚
â”‚  2. API-first - client apps can build their own Time Machine UI            â”‚
â”‚  3. AI-aware - simplified API lets AI help users navigate history          â”‚
â”‚  4. Real-time - see changes as they happen, not just hourly backups        â”‚
â”‚  5. Granular - restore single message OR entire conversation               â”‚
â”‚  6. Searchable - find that thing you said 3 months ago                     â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>
<h3 id="the-golden-rules">The Golden Rules</h3>
<ol type="1">
<li><strong>AUTOMATIC</strong> - Every action creates a snapshot. Users never â€œsave.â€</li>
<li><strong>INVISIBLE</strong> - Hidden until needed. Default UI is just simple chat.</li>
<li><strong>COMPLETE</strong> - Messages, files, edits, metadata - everything versioned.</li>
<li><strong>INSTANT</strong> - Restore happens in milliseconds, not minutes.</li>
<li><strong>FOREVER</strong> - Nothing is ever truly deleted. Soft-delete only.</li>
</ol>
<hr />
<h2 id="core-types">32.2 Core Types</h2>
<pre class="typescript"><code>// packages/shared/src/types/time-machine.ts

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TIME MACHINE CORE TYPES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export type SnapshotTrigger = 
  | &#39;message_sent&#39;       // User sent a message
  | &#39;message_received&#39;   // AI responded
  | &#39;message_edited&#39;     // User edited a message
  | &#39;message_deleted&#39;    // User &quot;deleted&quot; (soft) a message
  | &#39;file_uploaded&#39;      // User uploaded a file
  | &#39;file_generated&#39;     // AI generated a file
  | &#39;file_deleted&#39;       // User &quot;deleted&quot; (soft) a file
  | &#39;chat_renamed&#39;       // Chat title changed
  | &#39;restore_performed&#39;  // User restored from history
  | &#39;manual_snapshot&#39;;   // User explicitly saved a point

export type RestoreScope = 
  | &#39;full_chat&#39;          // Restore entire chat to that point
  | &#39;single_message&#39;     // Restore just one message
  | &#39;single_file&#39;        // Restore just one file
  | &#39;message_range&#39;      // Restore a range of messages
  | &#39;files_only&#39;;        // Restore all files, keep messages

export type MediaStatus = 
  | &#39;active&#39;             // Currently visible to user
  | &#39;processing&#39;         // Being uploaded/processed
  | &#39;archived&#39;           // Moved to cold storage (still retrievable)
  | &#39;soft_deleted&#39;;      // User &quot;deleted&quot; but still exists

export type ExportFormat = &#39;zip&#39; | &#39;json&#39; | &#39;markdown&#39; | &#39;pdf&#39; | &#39;html&#39;;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SNAPSHOT - Point in time capture of chat state
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface TimeMachineSnapshot {
  id: string;
  chatId: string;
  tenantId: string;
  
  // Version info
  version: number;                    // Monotonically increasing
  timestamp: string;                  // ISO 8601 with milliseconds
  
  // State summary at this point
  messageCount: number;
  fileCount: number;
  totalTokens: number;
  
  // What triggered this snapshot
  trigger: SnapshotTrigger;
  triggerDetails?: {
    messageId?: string;
    fileId?: string;
    description?: string;
  };
  
  // Lineage
  previousSnapshotId?: string;
  restoredFromSnapshotId?: string;    // If this was created by a restore
  
  // Integrity
  checksum: string;                   // SHA-256 of content
  
  // Metadata
  createdAt: string;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MESSAGE VERSION - Every edit creates a new version
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface MessageVersion {
  id: string;
  messageId: string;                  // Stable ID across versions
  tenantId: string;
  snapshotId: string;
  
  // Content
  content: string;
  role: &#39;user&#39; | &#39;assistant&#39; | &#39;system&#39;;
  modelId?: string;
  
  // Version info
  version: number;
  isActive: boolean;                  // Is this the current version?
  isSoftDeleted: boolean;
  
  // Edit tracking
  editReason?: string;
  editedBy?: string;
  
  // Timestamps
  createdAt: string;
  supersededAt?: string;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MEDIA VAULT - Every file version preserved forever
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface MediaVaultFile {
  id: string;
  chatId: string;
  tenantId: string;
  messageId?: string;
  snapshotId: string;
  
  // File identity
  originalName: string;               // What user named it
  displayName: string;                // What&#39;s shown in UI
  
  // S3 storage with versioning
  s3Bucket: string;
  s3Key: string;
  s3VersionId: string;                // Critical for immutability
  
  // File properties
  mimeType: string;
  sizeBytes: number;
  checksumSha256: string;
  
  // Preview
  thumbnailS3Key?: string;
  previewGenerated: boolean;
  
  // Version info
  version: number;
  previousVersionId?: string;
  
  // Source
  source: &#39;user_upload&#39; | &#39;ai_generated&#39; | &#39;system&#39;;
  
  // Status
  status: MediaStatus;
  
  // AI-enhanced metadata
  extractedText?: string;             // For searchability
  aiDescription?: string;             // AI-generated description
  
  // Timestamps
  createdAt: string;
  archivedAt?: string;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TIMELINE - Complete history of a chat
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface ChatTimeline {
  chatId: string;
  chatTitle: string;
  
  // Current state
  currentVersion: number;
  currentMessageCount: number;
  currentFileCount: number;
  
  // History
  snapshots: TimeMachineSnapshot[];
  
  // Aggregates
  totalSnapshots: number;
  totalMediaBytes: number;
  oldestSnapshot: string;             // ISO timestamp
  newestSnapshot: string;
  
  // Calendar data for navigation
  snapshotsByDate: Record&lt;string, number&gt;;  // &quot;2024-12-23&quot; -&gt; count
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RESTORE REQUEST/RESULT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface RestoreRequest {
  chatId: string;
  targetSnapshotId: string;
  scope: RestoreScope;
  
  // For partial restores
  messageIds?: string[];
  fileIds?: string[];
  
  // Reason tracking
  reason?: string;
}

export interface RestoreResult {
  success: boolean;
  newSnapshotId: string;
  
  // What was restored
  messagesRestored: number;
  filesRestored: number;
  
  // The new current state
  newVersion: number;
  
  // For undo
  previousSnapshotId: string;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXPORT BUNDLE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface ExportBundle {
  id: string;
  chatId: string;
  tenantId: string;
  userId: string;
  
  // Scope
  fromSnapshotId?: string;            // null = from beginning
  toSnapshotId: string;
  
  // Format
  format: ExportFormat;
  includeMedia: boolean;
  includeVersionHistory: boolean;
  
  // File
  s3Key: string;
  sizeBytes: number;
  downloadCount: number;
  
  // Expiry
  expiresAt: string;
  
  // Status
  status: &#39;pending&#39; | &#39;processing&#39; | &#39;ready&#39; | &#39;expired&#39; | &#39;failed&#39;;
  errorMessage?: string;
  
  // Timestamps
  createdAt: string;
  completedAt?: string;
}</code></pre>
<hr />
<h2 id="database-schema">32.3 Database Schema</h2>
<pre class="sql"><code>-- Migration 013: Time Machine for Think Tank
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CHAT SNAPSHOTS - Point-in-time state captures (like Time Machine backups)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE TABLE tm_snapshots (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id),
  chat_id UUID NOT NULL REFERENCES thinktank_chats(id) ON DELETE CASCADE,
  
  -- Version info
  version INTEGER NOT NULL,
  snapshot_timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  -- State summary
  message_count INTEGER NOT NULL DEFAULT 0,
  file_count INTEGER NOT NULL DEFAULT 0,
  total_tokens BIGINT NOT NULL DEFAULT 0,
  
  -- Trigger
  trigger TEXT NOT NULL CHECK (trigger IN (
    &#39;message_sent&#39;, &#39;message_received&#39;, &#39;message_edited&#39;, &#39;message_deleted&#39;,
    &#39;file_uploaded&#39;, &#39;file_generated&#39;, &#39;file_deleted&#39;, &#39;chat_renamed&#39;,
    &#39;restore_performed&#39;, &#39;manual_snapshot&#39;
  )),
  trigger_message_id UUID,
  trigger_file_id UUID,
  trigger_description TEXT,
  
  -- Lineage
  previous_snapshot_id UUID REFERENCES tm_snapshots(id),
  restored_from_snapshot_id UUID REFERENCES tm_snapshots(id),
  
  -- Integrity
  checksum TEXT NOT NULL,
  
  -- Timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  -- Constraints
  UNIQUE(chat_id, version)
);

-- Indexes for Time Machine navigation
CREATE INDEX idx_tm_snapshots_chat_version ON tm_snapshots(chat_id, version DESC);
CREATE INDEX idx_tm_snapshots_chat_timestamp ON tm_snapshots(chat_id, snapshot_timestamp DESC);
CREATE INDEX idx_tm_snapshots_date ON tm_snapshots(DATE(snapshot_timestamp), chat_id);

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MESSAGE VERSIONS - Every edit preserved
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE TABLE tm_message_versions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id),
  message_id UUID NOT NULL,           -- Stable ID across versions
  snapshot_id UUID NOT NULL REFERENCES tm_snapshots(id) ON DELETE CASCADE,
  
  -- Content
  content TEXT NOT NULL,
  role TEXT NOT NULL CHECK (role IN (&#39;user&#39;, &#39;assistant&#39;, &#39;system&#39;)),
  model_id TEXT,
  
  -- Metadata
  metadata JSONB DEFAULT &#39;{}&#39;,
  
  -- Version info
  version INTEGER NOT NULL,
  is_active BOOLEAN NOT NULL DEFAULT TRUE,
  is_soft_deleted BOOLEAN NOT NULL DEFAULT FALSE,
  
  -- Edit tracking
  edit_reason TEXT,
  edited_by UUID REFERENCES users(id),
  
  -- Timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  superseded_at TIMESTAMPTZ,
  original_created_at TIMESTAMPTZ NOT NULL,  -- When message was first created
  
  -- Constraints
  UNIQUE(message_id, version)
);

-- Indexes for message lookup
CREATE INDEX idx_tm_messages_message_id ON tm_message_versions(message_id, version DESC);
CREATE INDEX idx_tm_messages_snapshot ON tm_message_versions(snapshot_id);
CREATE INDEX idx_tm_messages_active ON tm_message_versions(message_id) WHERE is_active = TRUE;
CREATE INDEX idx_tm_messages_search ON tm_message_versions USING gin(to_tsvector(&#39;english&#39;, content));

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MEDIA VAULT - Every file version preserved forever
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE TABLE tm_media_vault (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id),
  chat_id UUID NOT NULL REFERENCES thinktank_chats(id) ON DELETE CASCADE,
  message_id UUID,                    -- Can be NULL for chat-level files
  snapshot_id UUID NOT NULL REFERENCES tm_snapshots(id) ON DELETE CASCADE,
  
  -- File identity
  original_name TEXT NOT NULL,
  display_name TEXT NOT NULL,
  
  -- S3 storage (with versioning enabled on bucket)
  s3_bucket TEXT NOT NULL,
  s3_key TEXT NOT NULL,
  s3_version_id TEXT NOT NULL,        -- S3 object version for immutability
  
  -- File properties
  mime_type TEXT NOT NULL,
  size_bytes BIGINT NOT NULL,
  checksum_sha256 TEXT NOT NULL,
  
  -- Preview
  thumbnail_s3_key TEXT,
  preview_generated BOOLEAN DEFAULT FALSE,
  
  -- Version info
  version INTEGER NOT NULL,
  previous_version_id UUID REFERENCES tm_media_vault(id),
  
  -- Source
  source TEXT NOT NULL CHECK (source IN (&#39;user_upload&#39;, &#39;ai_generated&#39;, &#39;system&#39;)),
  
  -- Status
  status TEXT NOT NULL DEFAULT &#39;active&#39; CHECK (status IN (
    &#39;active&#39;, &#39;processing&#39;, &#39;archived&#39;, &#39;soft_deleted&#39;
  )),
  
  -- AI-enhanced metadata
  extracted_text TEXT,
  ai_description TEXT,
  metadata JSONB DEFAULT &#39;{}&#39;,
  
  -- Timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  archived_at TIMESTAMPTZ,
  
  -- Constraints
  UNIQUE(chat_id, original_name, version)
);

-- Indexes for media lookup
CREATE INDEX idx_tm_media_chat ON tm_media_vault(chat_id);
CREATE INDEX idx_tm_media_snapshot ON tm_media_vault(snapshot_id);
CREATE INDEX idx_tm_media_name ON tm_media_vault(chat_id, original_name, version DESC);
CREATE INDEX idx_tm_media_search ON tm_media_vault USING gin(
  to_tsvector(&#39;english&#39;, COALESCE(extracted_text, &#39;&#39;) || &#39; &#39; || COALESCE(ai_description, &#39;&#39;))
);

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MESSAGE-MEDIA REFERENCES - Links messages to specific file versions
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE TABLE tm_message_media_refs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  message_version_id UUID NOT NULL REFERENCES tm_message_versions(id) ON DELETE CASCADE,
  media_vault_id UUID NOT NULL REFERENCES tm_media_vault(id) ON DELETE CASCADE,
  
  -- Display order and type
  display_order INTEGER NOT NULL DEFAULT 0,
  reference_type TEXT NOT NULL CHECK (reference_type IN (
    &#39;attachment&#39;,     -- User attached this file
    &#39;inline&#39;,         -- Embedded in message content
    &#39;result&#39;,         -- AI-generated result
    &#39;reference&#39;       -- Referenced but not attached
  )),
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  UNIQUE(message_version_id, media_vault_id)
);

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- RESTORE LOG - Audit trail for all restores
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE TABLE tm_restore_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id),
  chat_id UUID NOT NULL REFERENCES thinktank_chats(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id),
  
  -- What was restored
  from_snapshot_id UUID NOT NULL REFERENCES tm_snapshots(id),
  to_snapshot_id UUID NOT NULL REFERENCES tm_snapshots(id),
  
  -- Scope
  scope TEXT NOT NULL CHECK (scope IN (
    &#39;full_chat&#39;, &#39;single_message&#39;, &#39;single_file&#39;, &#39;message_range&#39;, &#39;files_only&#39;
  )),
  
  -- Items restored
  message_ids UUID[],
  file_ids UUID[],
  messages_restored INTEGER DEFAULT 0,
  files_restored INTEGER DEFAULT 0,
  
  -- Reason
  reason TEXT,
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- EXPORT BUNDLES - Track export requests
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE TABLE tm_export_bundles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id),
  chat_id UUID NOT NULL REFERENCES thinktank_chats(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id),
  
  -- Scope
  from_snapshot_id UUID REFERENCES tm_snapshots(id),
  to_snapshot_id UUID NOT NULL REFERENCES tm_snapshots(id),
  
  -- Format
  format TEXT NOT NULL CHECK (format IN (&#39;zip&#39;, &#39;json&#39;, &#39;markdown&#39;, &#39;pdf&#39;, &#39;html&#39;)),
  include_media BOOLEAN DEFAULT TRUE,
  include_version_history BOOLEAN DEFAULT FALSE,
  
  -- File
  s3_key TEXT,
  size_bytes BIGINT DEFAULT 0,
  download_count INTEGER DEFAULT 0,
  
  -- Status
  status TEXT NOT NULL DEFAULT &#39;pending&#39; CHECK (status IN (
    &#39;pending&#39;, &#39;processing&#39;, &#39;ready&#39;, &#39;expired&#39;, &#39;failed&#39;
  )),
  error_message TEXT,
  
  -- Expiry
  expires_at TIMESTAMPTZ NOT NULL DEFAULT (NOW() + INTERVAL &#39;7 days&#39;),
  
  -- Timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  completed_at TIMESTAMPTZ
);

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ROW LEVEL SECURITY
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ALTER TABLE tm_snapshots ENABLE ROW LEVEL SECURITY;
ALTER TABLE tm_message_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE tm_media_vault ENABLE ROW LEVEL SECURITY;
ALTER TABLE tm_message_media_refs ENABLE ROW LEVEL SECURITY;
ALTER TABLE tm_restore_log ENABLE ROW LEVEL SECURITY;
ALTER TABLE tm_export_bundles ENABLE ROW LEVEL SECURITY;

-- Tenant isolation policies
CREATE POLICY tm_snapshots_tenant ON tm_snapshots 
  USING (tenant_id = current_setting(&#39;app.current_tenant_id&#39;)::UUID);

CREATE POLICY tm_message_versions_tenant ON tm_message_versions 
  USING (tenant_id = current_setting(&#39;app.current_tenant_id&#39;)::UUID);

CREATE POLICY tm_media_vault_tenant ON tm_media_vault 
  USING (tenant_id = current_setting(&#39;app.current_tenant_id&#39;)::UUID);

CREATE POLICY tm_message_media_refs_tenant ON tm_message_media_refs
  USING (EXISTS (
    SELECT 1 FROM tm_message_versions mv 
    WHERE mv.id = tm_message_media_refs.message_version_id 
    AND mv.tenant_id = current_setting(&#39;app.current_tenant_id&#39;)::UUID
  ));

CREATE POLICY tm_restore_log_tenant ON tm_restore_log 
  USING (tenant_id = current_setting(&#39;app.current_tenant_id&#39;)::UUID);

CREATE POLICY tm_export_bundles_tenant ON tm_export_bundles 
  USING (tenant_id = current_setting(&#39;app.current_tenant_id&#39;)::UUID);

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- VIEWS FOR COMMON QUERIES
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Current state view (what users see in normal mode)
CREATE VIEW tm_current_messages AS
SELECT 
  mv.message_id,
  mv.content,
  mv.role,
  mv.model_id,
  mv.metadata,
  mv.version,
  mv.original_created_at,
  mv.created_at as version_created_at,
  s.chat_id,
  s.tenant_id
FROM tm_message_versions mv
JOIN tm_snapshots s ON mv.snapshot_id = s.id
WHERE mv.is_active = TRUE AND mv.is_soft_deleted = FALSE;

-- Files with version count
CREATE VIEW tm_files_with_versions AS
SELECT 
  mv.*,
  (SELECT COUNT(*) FROM tm_media_vault 
   WHERE chat_id = mv.chat_id AND original_name = mv.original_name) as version_count
FROM tm_media_vault mv
WHERE mv.status = &#39;active&#39;;

-- Calendar view for timeline navigation
CREATE VIEW tm_calendar_view AS
SELECT 
  chat_id,
  DATE(snapshot_timestamp) as snapshot_date,
  COUNT(*) as snapshot_count,
  MIN(snapshot_timestamp) as first_snapshot,
  MAX(snapshot_timestamp) as last_snapshot
FROM tm_snapshots
GROUP BY chat_id, DATE(snapshot_timestamp)
ORDER BY snapshot_date DESC;</code></pre>
<hr />
<h2 id="time-machine-service-core-business-logic">32.4 Time Machine Service (Core Business Logic)</h2>
<pre class="typescript"><code>// packages/functions/src/services/time-machine.service.ts

import { Pool, PoolClient } from &#39;pg&#39;;
import { S3Client, PutObjectCommand, GetObjectCommand, CopyObjectCommand, HeadObjectCommand } from &#39;@aws-sdk/client-s3&#39;;
import { getSignedUrl } from &#39;@aws-sdk/s3-request-presigner&#39;;
import { createHash } from &#39;crypto&#39;;
import { v4 as uuid } from &#39;uuid&#39;;
import {
  TimeMachineSnapshot,
  MessageVersion,
  MediaVaultFile,
  ChatTimeline,
  RestoreRequest,
  RestoreResult,
  ExportBundle,
  SnapshotTrigger,
  RestoreScope,
  ExportFormat,
} from &#39;@radiant/shared&#39;;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TIME MACHINE SERVICE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export class TimeMachineService {
  private pool: Pool;
  private s3: S3Client;
  private bucketName: string;
  
  constructor(pool: Pool) {
    this.pool = pool;
    this.s3 = new S3Client({});
    this.bucketName = process.env.MEDIA_VAULT_BUCKET!;
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SNAPSHOT CREATION (Automatic on every action)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  async createSnapshot(params: {
    chatId: string;
    tenantId: string;
    trigger: SnapshotTrigger;
    triggerMessageId?: string;
    triggerFileId?: string;
    triggerDescription?: string;
  }): Promise&lt;TimeMachineSnapshot&gt; {
    const client = await this.pool.connect();
    
    try {
      await client.query(&#39;BEGIN&#39;);
      await client.query(`SET app.current_tenant_id = &#39;${params.tenantId}&#39;`);
      
      // Get previous snapshot
      const prevResult = await client.query(`
        SELECT id, version FROM tm_snapshots 
        WHERE chat_id = $1 
        ORDER BY version DESC LIMIT 1
      `, [params.chatId]);
      
      const prevSnapshot = prevResult.rows[0];
      const newVersion = prevSnapshot ? prevSnapshot.version + 1 : 1;
      
      // Count current state
      const countsResult = await client.query(`
        SELECT 
          (SELECT COUNT(DISTINCT message_id) FROM tm_message_versions mv
           JOIN tm_snapshots s ON mv.snapshot_id = s.id
           WHERE s.chat_id = $1 AND mv.is_active = TRUE AND mv.is_soft_deleted = FALSE) as message_count,
          (SELECT COUNT(*) FROM tm_media_vault 
           WHERE chat_id = $1 AND status = &#39;active&#39;) as file_count,
          (SELECT COALESCE(SUM((metadata-&gt;&gt;&#39;tokens&#39;)::bigint), 0) FROM tm_message_versions mv
           JOIN tm_snapshots s ON mv.snapshot_id = s.id
           WHERE s.chat_id = $1 AND mv.is_active = TRUE) as total_tokens
      `, [params.chatId]);
      
      const counts = countsResult.rows[0];
      
      // Compute checksum of current state
      const checksum = await this.computeChatChecksum(client, params.chatId);
      
      // Create snapshot
      const result = await client.query(`
        INSERT INTO tm_snapshots (
          tenant_id, chat_id, version, message_count, file_count, total_tokens,
          trigger, trigger_message_id, trigger_file_id, trigger_description,
          previous_snapshot_id, checksum
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
        RETURNING *
      `, [
        params.tenantId,
        params.chatId,
        newVersion,
        parseInt(counts.message_count) || 0,
        parseInt(counts.file_count) || 0,
        parseInt(counts.total_tokens) || 0,
        params.trigger,
        params.triggerMessageId,
        params.triggerFileId,
        params.triggerDescription,
        prevSnapshot?.id,
        checksum,
      ]);
      
      await client.query(&#39;COMMIT&#39;);
      
      return this.mapSnapshotRow(result.rows[0]);
    } catch (error) {
      await client.query(&#39;ROLLBACK&#39;);
      throw error;
    } finally {
      client.release();
    }
  }
  
  private async computeChatChecksum(client: PoolClient, chatId: string): Promise&lt;string&gt; {
    const result = await client.query(`
      SELECT mv.message_id, mv.content, mv.role, mv.version
      FROM tm_message_versions mv
      JOIN tm_snapshots s ON mv.snapshot_id = s.id
      WHERE s.chat_id = $1 AND mv.is_active = TRUE AND mv.is_soft_deleted = FALSE
      ORDER BY mv.original_created_at ASC
    `, [chatId]);
    
    const hash = createHash(&#39;sha256&#39;);
    for (const row of result.rows) {
      hash.update(`${row.message_id}:${row.content}:${row.role}:${row.version}|`);
    }
    return hash.digest(&#39;hex&#39;);
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // MESSAGE VERSIONING
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  async saveMessageVersion(params: {
    chatId: string;
    tenantId: string;
    messageId: string;
    content: string;
    role: &#39;user&#39; | &#39;assistant&#39; | &#39;system&#39;;
    modelId?: string;
    metadata?: Record&lt;string, unknown&gt;;
    isEdit?: boolean;
    editReason?: string;
    editedBy?: string;
  }): Promise&lt;MessageVersion&gt; {
    const client = await this.pool.connect();
    
    try {
      await client.query(&#39;BEGIN&#39;);
      await client.query(`SET app.current_tenant_id = &#39;${params.tenantId}&#39;`);
      
      // Get or create snapshot
      let snapshot = await this.getLatestSnapshot(client, params.chatId);
      if (!snapshot) {
        // Create initial snapshot
        await client.query(&#39;COMMIT&#39;);
        snapshot = await this.createSnapshot({
          chatId: params.chatId,
          tenantId: params.tenantId,
          trigger: params.role === &#39;user&#39; ? &#39;message_sent&#39; : &#39;message_received&#39;,
        });
        await client.query(&#39;BEGIN&#39;);
        await client.query(`SET app.current_tenant_id = &#39;${params.tenantId}&#39;`);
      }
      
      // Get previous version of this message (if editing)
      const prevResult = await client.query(`
        SELECT id, version FROM tm_message_versions 
        WHERE message_id = $1 AND is_active = TRUE
        ORDER BY version DESC LIMIT 1
      `, [params.messageId]);
      
      const prevVersion = prevResult.rows[0];
      const newVersion = prevVersion ? prevVersion.version + 1 : 1;
      
      // If editing, mark previous as superseded
      if (prevVersion) {
        await client.query(`
          UPDATE tm_message_versions 
          SET is_active = FALSE, superseded_at = NOW()
          WHERE id = $1
        `, [prevVersion.id]);
      }
      
      // Insert new version
      const result = await client.query(`
        INSERT INTO tm_message_versions (
          tenant_id, message_id, snapshot_id, content, role, model_id,
          metadata, version, is_active, edit_reason, edited_by, original_created_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, TRUE, $9, $10, 
          COALESCE((SELECT original_created_at FROM tm_message_versions WHERE message_id = $2 LIMIT 1), NOW())
        )
        RETURNING *
      `, [
        params.tenantId,
        params.messageId,
        snapshot.id,
        params.content,
        params.role,
        params.modelId,
        JSON.stringify(params.metadata || {}),
        newVersion,
        params.editReason,
        params.editedBy,
      ]);
      
      await client.query(&#39;COMMIT&#39;);
      
      // Create snapshot for this change
      await this.createSnapshot({
        chatId: params.chatId,
        tenantId: params.tenantId,
        trigger: params.isEdit ? &#39;message_edited&#39; : (params.role === &#39;user&#39; ? &#39;message_sent&#39; : &#39;message_received&#39;),
        triggerMessageId: params.messageId,
      });
      
      return this.mapMessageVersionRow(result.rows[0]);
    } catch (error) {
      await client.query(&#39;ROLLBACK&#39;);
      throw error;
    } finally {
      client.release();
    }
  }
  
  async softDeleteMessage(params: {
    chatId: string;
    tenantId: string;
    messageId: string;
    deletedBy: string;
  }): Promise&lt;void&gt; {
    const client = await this.pool.connect();
    
    try {
      await client.query(&#39;BEGIN&#39;);
      await client.query(`SET app.current_tenant_id = &#39;${params.tenantId}&#39;`);
      
      // Mark as soft deleted (NEVER actually delete)
      await client.query(`
        UPDATE tm_message_versions 
        SET is_soft_deleted = TRUE, superseded_at = NOW()
        WHERE message_id = $1 AND is_active = TRUE
      `, [params.messageId]);
      
      await client.query(&#39;COMMIT&#39;);
      
      // Create snapshot
      await this.createSnapshot({
        chatId: params.chatId,
        tenantId: params.tenantId,
        trigger: &#39;message_deleted&#39;,
        triggerMessageId: params.messageId,
      });
    } catch (error) {
      await client.query(&#39;ROLLBACK&#39;);
      throw error;
    } finally {
      client.release();
    }
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // MEDIA VAULT
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  async uploadFile(params: {
    chatId: string;
    tenantId: string;
    messageId?: string;
    file: {
      name: string;
      data: Buffer;
      mimeType: string;
    };
    source: &#39;user_upload&#39; | &#39;ai_generated&#39; | &#39;system&#39;;
  }): Promise&lt;MediaVaultFile&gt; {
    const client = await this.pool.connect();
    
    try {
      await client.query(&#39;BEGIN&#39;);
      await client.query(`SET app.current_tenant_id = &#39;${params.tenantId}&#39;`);
      
      // Get or create snapshot
      let snapshot = await this.getLatestSnapshot(client, params.chatId);
      if (!snapshot) {
        await client.query(&#39;COMMIT&#39;);
        snapshot = await this.createSnapshot({
          chatId: params.chatId,
          tenantId: params.tenantId,
          trigger: &#39;file_uploaded&#39;,
        });
        await client.query(&#39;BEGIN&#39;);
        await client.query(`SET app.current_tenant_id = &#39;${params.tenantId}&#39;`);
      }
      
      // Check for existing versions
      const existingResult = await client.query(`
        SELECT id, version FROM tm_media_vault 
        WHERE chat_id = $1 AND original_name = $2
        ORDER BY version DESC LIMIT 1
      `, [params.chatId, params.file.name]);
      
      const existing = existingResult.rows[0];
      const newVersion = existing ? existing.version + 1 : 1;
      
      // Compute checksum
      const checksum = createHash(&#39;sha256&#39;).update(params.file.data).digest(&#39;hex&#39;);
      
      // Generate S3 key
      const fileId = uuid();
      const s3Key = `${params.tenantId}/${params.chatId}/${fileId}/${params.file.name}`;
      
      // Upload to S3 (bucket has versioning enabled)
      const putResult = await this.s3.send(new PutObjectCommand({
        Bucket: this.bucketName,
        Key: s3Key,
        Body: params.file.data,
        ContentType: params.file.mimeType,
        Metadata: {
          &#39;chat-id&#39;: params.chatId,
          &#39;original-name&#39;: params.file.name,
          &#39;version&#39;: String(newVersion),
          &#39;checksum&#39;: checksum,
        },
      }));
      
      // Insert into media vault
      const result = await client.query(`
        INSERT INTO tm_media_vault (
          tenant_id, chat_id, message_id, snapshot_id, original_name, display_name,
          s3_bucket, s3_key, s3_version_id, mime_type, size_bytes, checksum_sha256,
          version, previous_version_id, source
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
        RETURNING *
      `, [
        params.tenantId,
        params.chatId,
        params.messageId,
        snapshot.id,
        params.file.name,
        params.file.name,
        this.bucketName,
        s3Key,
        putResult.VersionId!,
        params.file.mimeType,
        params.file.data.length,
        checksum,
        newVersion,
        existing?.id,
        params.source,
      ]);
      
      await client.query(&#39;COMMIT&#39;);
      
      // Create snapshot
      await this.createSnapshot({
        chatId: params.chatId,
        tenantId: params.tenantId,
        trigger: params.source === &#39;user_upload&#39; ? &#39;file_uploaded&#39; : &#39;file_generated&#39;,
        triggerFileId: result.rows[0].id,
      });
      
      return this.mapMediaVaultRow(result.rows[0]);
    } catch (error) {
      await client.query(&#39;ROLLBACK&#39;);
      throw error;
    } finally {
      client.release();
    }
  }
  
  async getFileDownloadUrl(fileId: string, expiresIn = 3600): Promise&lt;string&gt; {
    const result = await this.pool.query(`
      SELECT s3_bucket, s3_key, s3_version_id FROM tm_media_vault WHERE id = $1
    `, [fileId]);
    
    if (!result.rows[0]) {
      throw new Error(&#39;File not found&#39;);
    }
    
    const { s3_bucket, s3_key, s3_version_id } = result.rows[0];
    
    const command = new GetObjectCommand({
      Bucket: s3_bucket,
      Key: s3_key,
      VersionId: s3_version_id,
    });
    
    return getSignedUrl(this.s3, command, { expiresIn });
  }
  
  async getFileVersions(chatId: string, fileName: string): Promise&lt;MediaVaultFile[]&gt; {
    const result = await this.pool.query(`
      SELECT * FROM tm_media_vault 
      WHERE chat_id = $1 AND original_name = $2
      ORDER BY version DESC
    `, [chatId, fileName]);
    
    return result.rows.map(row =&gt; this.mapMediaVaultRow(row));
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TIMELINE NAVIGATION (The &quot;fly back through time&quot; experience)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  async getTimeline(chatId: string, tenantId: string): Promise&lt;ChatTimeline&gt; {
    await this.pool.query(`SET app.current_tenant_id = &#39;${tenantId}&#39;`);
    
    // Get chat info
    const chatResult = await this.pool.query(`
      SELECT title FROM thinktank_chats WHERE id = $1
    `, [chatId]);
    
    // Get all snapshots
    const snapshotsResult = await this.pool.query(`
      SELECT * FROM tm_snapshots 
      WHERE chat_id = $1
      ORDER BY version ASC
    `, [chatId]);
    
    // Get calendar data
    const calendarResult = await this.pool.query(`
      SELECT snapshot_date::text, snapshot_count
      FROM tm_calendar_view
      WHERE chat_id = $1
    `, [chatId]);
    
    // Get total media size
    const sizeResult = await this.pool.query(`
      SELECT COALESCE(SUM(size_bytes), 0) as total_size
      FROM tm_media_vault
      WHERE chat_id = $1
    `, [chatId]);
    
    const snapshots = snapshotsResult.rows.map(row =&gt; this.mapSnapshotRow(row));
    const currentSnapshot = snapshots[snapshots.length - 1];
    
    const snapshotsByDate: Record&lt;string, number&gt; = {};
    for (const row of calendarResult.rows) {
      snapshotsByDate[row.snapshot_date] = parseInt(row.snapshot_count);
    }
    
    return {
      chatId,
      chatTitle: chatResult.rows[0]?.title || &#39;Untitled Chat&#39;,
      currentVersion: currentSnapshot?.version || 0,
      currentMessageCount: currentSnapshot?.messageCount || 0,
      currentFileCount: currentSnapshot?.fileCount || 0,
      snapshots,
      totalSnapshots: snapshots.length,
      totalMediaBytes: parseInt(sizeResult.rows[0].total_size) || 0,
      oldestSnapshot: snapshots[0]?.timestamp || new Date().toISOString(),
      newestSnapshot: currentSnapshot?.timestamp || new Date().toISOString(),
      snapshotsByDate,
    };
  }
  
  async getChatAtSnapshot(chatId: string, snapshotId: string, tenantId: string): Promise&lt;{
    snapshot: TimeMachineSnapshot;
    messages: MessageVersion[];
    files: MediaVaultFile[];
  }&gt; {
    await this.pool.query(`SET app.current_tenant_id = &#39;${tenantId}&#39;`);
    
    // Get snapshot
    const snapshotResult = await this.pool.query(`
      SELECT * FROM tm_snapshots WHERE id = $1
    `, [snapshotId]);
    
    if (!snapshotResult.rows[0]) {
      throw new Error(&#39;Snapshot not found&#39;);
    }
    
    // Get messages at this snapshot
    // This requires understanding the chain - we need messages that were active AT this snapshot
    const messagesResult = await this.pool.query(`
      WITH snapshot_chain AS (
        SELECT id, version FROM tm_snapshots
        WHERE chat_id = $1 AND version &lt;= (SELECT version FROM tm_snapshots WHERE id = $2)
      )
      SELECT DISTINCT ON (mv.message_id) mv.*
      FROM tm_message_versions mv
      WHERE mv.snapshot_id IN (SELECT id FROM snapshot_chain)
        AND NOT mv.is_soft_deleted
      ORDER BY mv.message_id, mv.version DESC
    `, [chatId, snapshotId]);
    
    // Get files at this snapshot
    const filesResult = await this.pool.query(`
      WITH snapshot_chain AS (
        SELECT id, version FROM tm_snapshots
        WHERE chat_id = $1 AND version &lt;= (SELECT version FROM tm_snapshots WHERE id = $2)
      )
      SELECT DISTINCT ON (mf.original_name) mf.*
      FROM tm_media_vault mf
      WHERE mf.snapshot_id IN (SELECT id FROM snapshot_chain)
        AND mf.status != &#39;soft_deleted&#39;
      ORDER BY mf.original_name, mf.version DESC
    `, [chatId, snapshotId]);
    
    return {
      snapshot: this.mapSnapshotRow(snapshotResult.rows[0]),
      messages: messagesResult.rows.map(row =&gt; this.mapMessageVersionRow(row)),
      files: filesResult.rows.map(row =&gt; this.mapMediaVaultRow(row)),
    };
  }
  
  async getSnapshotsByDate(chatId: string, date: string, tenantId: string): Promise&lt;TimeMachineSnapshot[]&gt; {
    await this.pool.query(`SET app.current_tenant_id = &#39;${tenantId}&#39;`);
    
    const result = await this.pool.query(`
      SELECT * FROM tm_snapshots 
      WHERE chat_id = $1 AND DATE(snapshot_timestamp) = $2
      ORDER BY snapshot_timestamp ASC
    `, [chatId, date]);
    
    return result.rows.map(row =&gt; this.mapSnapshotRow(row));
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // RESTORE (One-click recovery)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  async restore(request: RestoreRequest, userId: string, tenantId: string): Promise&lt;RestoreResult&gt; {
    const client = await this.pool.connect();
    
    try {
      await client.query(&#39;BEGIN&#39;);
      await client.query(`SET app.current_tenant_id = &#39;${tenantId}&#39;`);
      
      // Get target snapshot state
      const targetState = await this.getChatAtSnapshot(request.chatId, request.targetSnapshotId, tenantId);
      
      // Get current snapshot for logging
      const currentSnapshot = await this.getLatestSnapshot(client, request.chatId);
      
      let messagesRestored = 0;
      let filesRestored = 0;
      
      switch (request.scope) {
        case &#39;full_chat&#39;:
          // Restore all messages and files
          messagesRestored = await this.restoreMessages(client, targetState.messages, request.chatId, tenantId);
          filesRestored = await this.restoreFiles(client, targetState.files, request.chatId, tenantId);
          break;
          
        case &#39;single_message&#39;:
          if (request.messageIds?.length) {
            const targetMessages = targetState.messages.filter(m =&gt; request.messageIds!.includes(m.messageId));
            messagesRestored = await this.restoreMessages(client, targetMessages, request.chatId, tenantId);
          }
          break;
          
        case &#39;single_file&#39;:
          if (request.fileIds?.length) {
            const targetFiles = targetState.files.filter(f =&gt; request.fileIds!.includes(f.id));
            filesRestored = await this.restoreFiles(client, targetFiles, request.chatId, tenantId);
          }
          break;
          
        case &#39;files_only&#39;:
          filesRestored = await this.restoreFiles(client, targetState.files, request.chatId, tenantId);
          break;
      }
      
      await client.query(&#39;COMMIT&#39;);
      
      // Create restore snapshot
      const newSnapshot = await this.createSnapshot({
        chatId: request.chatId,
        tenantId,
        trigger: &#39;restore_performed&#39;,
        triggerDescription: `Restored to version ${targetState.snapshot.version}`,
      });
      
      // Log the restore
      await this.pool.query(`
        INSERT INTO tm_restore_log (
          tenant_id, chat_id, user_id, from_snapshot_id, to_snapshot_id,
          scope, message_ids, file_ids, messages_restored, files_restored, reason
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
      `, [
        tenantId,
        request.chatId,
        userId,
        request.targetSnapshotId,
        newSnapshot.id,
        request.scope,
        request.messageIds || [],
        request.fileIds || [],
        messagesRestored,
        filesRestored,
        request.reason,
      ]);
      
      return {
        success: true,
        newSnapshotId: newSnapshot.id,
        messagesRestored,
        filesRestored,
        newVersion: newSnapshot.version,
        previousSnapshotId: currentSnapshot?.id || &#39;&#39;,
      };
    } catch (error) {
      await client.query(&#39;ROLLBACK&#39;);
      throw error;
    } finally {
      client.release();
    }
  }
  
  private async restoreMessages(
    client: PoolClient, 
    messages: MessageVersion[], 
    chatId: string, 
    tenantId: string
  ): Promise&lt;number&gt; {
    // Deactivate current versions
    await client.query(`
      UPDATE tm_message_versions 
      SET is_active = FALSE, superseded_at = NOW()
      WHERE message_id IN (
        SELECT DISTINCT message_id FROM tm_message_versions mv
        JOIN tm_snapshots s ON mv.snapshot_id = s.id
        WHERE s.chat_id = $1 AND mv.is_active = TRUE
      )
    `, [chatId]);
    
    // Get latest snapshot
    const snapshot = await this.getLatestSnapshot(client, chatId);
    
    // Insert restored versions as new active versions
    for (const msg of messages) {
      await client.query(`
        INSERT INTO tm_message_versions (
          tenant_id, message_id, snapshot_id, content, role, model_id,
          metadata, version, is_active, edit_reason, original_created_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, 
          (SELECT COALESCE(MAX(version), 0) + 1 FROM tm_message_versions WHERE message_id = $2),
          TRUE, &#39;Restored from Time Machine&#39;, $8)
      `, [
        tenantId,
        msg.messageId,
        snapshot?.id,
        msg.content,
        msg.role,
        msg.modelId,
        JSON.stringify(msg.metadata || {}),
        msg.createdAt,
      ]);
    }
    
    return messages.length;
  }
  
  private async restoreFiles(
    client: PoolClient,
    files: MediaVaultFile[],
    chatId: string,
    tenantId: string
  ): Promise&lt;number&gt; {
    // Mark current files as soft deleted
    await client.query(`
      UPDATE tm_media_vault 
      SET status = &#39;soft_deleted&#39;
      WHERE chat_id = $1 AND status = &#39;active&#39;
    `, [chatId]);
    
    // Get latest snapshot
    const snapshot = await this.getLatestSnapshot(client, chatId);
    
    // &quot;Restore&quot; files by creating new active versions pointing to same S3 objects
    for (const file of files) {
      await client.query(`
        INSERT INTO tm_media_vault (
          tenant_id, chat_id, message_id, snapshot_id, original_name, display_name,
          s3_bucket, s3_key, s3_version_id, mime_type, size_bytes, checksum_sha256,
          version, previous_version_id, source, status, extracted_text, ai_description
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12,
          (SELECT COALESCE(MAX(version), 0) + 1 FROM tm_media_vault WHERE chat_id = $2 AND original_name = $5),
          $13, $14, &#39;active&#39;, $15, $16)
      `, [
        tenantId,
        chatId,
        file.messageId,
        snapshot?.id,
        file.originalName,
        file.displayName,
        file.s3Bucket,
        file.s3Key,
        file.s3VersionId,
        file.mimeType,
        file.sizeBytes,
        file.checksumSha256,
        file.id,
        file.source,
        file.extractedText,
        file.aiDescription,
      ]);
    }
    
    return files.length;
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SEARCH (Find that thing from 3 months ago)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  async searchMessages(chatId: string, query: string, tenantId: string): Promise&lt;MessageVersion[]&gt; {
    await this.pool.query(`SET app.current_tenant_id = &#39;${tenantId}&#39;`);
    
    const result = await this.pool.query(`
      SELECT DISTINCT ON (mv.message_id) mv.*, 
        ts_rank(to_tsvector(&#39;english&#39;, mv.content), plainto_tsquery(&#39;english&#39;, $2)) as rank
      FROM tm_message_versions mv
      JOIN tm_snapshots s ON mv.snapshot_id = s.id
      WHERE s.chat_id = $1 
        AND to_tsvector(&#39;english&#39;, mv.content) @@ plainto_tsquery(&#39;english&#39;, $2)
      ORDER BY mv.message_id, rank DESC, mv.version DESC
      LIMIT 50
    `, [chatId, query]);
    
    return result.rows.map(row =&gt; this.mapMessageVersionRow(row));
  }
  
  async searchFiles(chatId: string, query: string, tenantId: string): Promise&lt;MediaVaultFile[]&gt; {
    await this.pool.query(`SET app.current_tenant_id = &#39;${tenantId}&#39;`);
    
    const result = await this.pool.query(`
      SELECT DISTINCT ON (original_name) *,
        ts_rank(
          to_tsvector(&#39;english&#39;, COALESCE(extracted_text, &#39;&#39;) || &#39; &#39; || COALESCE(ai_description, &#39;&#39;)),
          plainto_tsquery(&#39;english&#39;, $2)
        ) as rank
      FROM tm_media_vault
      WHERE chat_id = $1 
        AND (
          original_name ILIKE &#39;%&#39; || $2 || &#39;%&#39;
          OR to_tsvector(&#39;english&#39;, COALESCE(extracted_text, &#39;&#39;) || &#39; &#39; || COALESCE(ai_description, &#39;&#39;)) 
             @@ plainto_tsquery(&#39;english&#39;, $2)
        )
      ORDER BY original_name, rank DESC, version DESC
      LIMIT 50
    `, [chatId, query]);
    
    return result.rows.map(row =&gt; this.mapMediaVaultRow(row));
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // EXPORT
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  async createExportBundle(params: {
    chatId: string;
    tenantId: string;
    userId: string;
    format: ExportFormat;
    includeMedia: boolean;
    includeVersionHistory: boolean;
    fromSnapshotId?: string;
  }): Promise&lt;string&gt; {
    // Get current snapshot
    const currentResult = await this.pool.query(`
      SELECT id FROM tm_snapshots 
      WHERE chat_id = $1 
      ORDER BY version DESC LIMIT 1
    `, [params.chatId]);
    
    const bundleId = uuid();
    
    await this.pool.query(`
      INSERT INTO tm_export_bundles (
        id, tenant_id, chat_id, user_id, from_snapshot_id, to_snapshot_id,
        format, include_media, include_version_history, status
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, &#39;pending&#39;)
    `, [
      bundleId,
      params.tenantId,
      params.chatId,
      params.userId,
      params.fromSnapshotId,
      currentResult.rows[0]?.id,
      params.format,
      params.includeMedia,
      params.includeVersionHistory,
    ]);
    
    // Trigger async export via SQS - see Section 33.5 for export queue handler
    // await sqs.send(new SendMessageCommand({
    //   QueueUrl: process.env.EXPORT_QUEUE_URL,
    //   MessageBody: JSON.stringify({ chatId, format, includeMedia }),
    // }));
    
    return bundleId;
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // HELPERS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  private async getLatestSnapshot(client: PoolClient, chatId: string): Promise&lt;TimeMachineSnapshot | null&gt; {
    const result = await client.query(`
      SELECT * FROM tm_snapshots 
      WHERE chat_id = $1 
      ORDER BY version DESC LIMIT 1
    `, [chatId]);
    
    return result.rows[0] ? this.mapSnapshotRow(result.rows[0]) : null;
  }
  
  private mapSnapshotRow(row: any): TimeMachineSnapshot {
    return {
      id: row.id,
      chatId: row.chat_id,
      tenantId: row.tenant_id,
      version: row.version,
      timestamp: row.snapshot_timestamp,
      messageCount: row.message_count,
      fileCount: row.file_count,
      totalTokens: row.total_tokens,
      trigger: row.trigger,
      triggerDetails: {
        messageId: row.trigger_message_id,
        fileId: row.trigger_file_id,
        description: row.trigger_description,
      },
      previousSnapshotId: row.previous_snapshot_id,
      restoredFromSnapshotId: row.restored_from_snapshot_id,
      checksum: row.checksum,
      createdAt: row.created_at,
    };
  }
  
  private mapMessageVersionRow(row: any): MessageVersion {
    return {
      id: row.id,
      messageId: row.message_id,
      tenantId: row.tenant_id,
      snapshotId: row.snapshot_id,
      content: row.content,
      role: row.role,
      modelId: row.model_id,
      version: row.version,
      isActive: row.is_active,
      isSoftDeleted: row.is_soft_deleted,
      editReason: row.edit_reason,
      editedBy: row.edited_by,
      createdAt: row.created_at,
      supersededAt: row.superseded_at,
    };
  }
  
  private mapMediaVaultRow(row: any): MediaVaultFile {
    return {
      id: row.id,
      chatId: row.chat_id,
      tenantId: row.tenant_id,
      messageId: row.message_id,
      snapshotId: row.snapshot_id,
      originalName: row.original_name,
      displayName: row.display_name,
      s3Bucket: row.s3_bucket,
      s3Key: row.s3_key,
      s3VersionId: row.s3_version_id,
      mimeType: row.mime_type,
      sizeBytes: row.size_bytes,
      checksumSha256: row.checksum_sha256,
      thumbnailS3Key: row.thumbnail_s3_key,
      previewGenerated: row.preview_generated,
      version: row.version,
      previousVersionId: row.previous_version_id,
      source: row.source,
      status: row.status,
      extractedText: row.extracted_text,
      aiDescription: row.ai_description,
      createdAt: row.created_at,
      archivedAt: row.archived_at,
    };
  }
}</code></pre>
<hr />
<h2 id="complex-api-handlers-service-layer-exposure">32.5 Complex API Handlers (Service Layer Exposure)</h2>
<pre class="typescript"><code>// packages/functions/src/handlers/thinktank/time-machine.handlers.ts

import { APIGatewayProxyEvent, APIGatewayProxyResult } from &#39;aws-lambda&#39;;
import { TimeMachineService } from &#39;../../services/time-machine.service&#39;;
import { pool } from &#39;../../utils/db&#39;;
import { RestoreScope, ExportFormat } from &#39;@radiant/shared&#39;;

const service = new TimeMachineService(pool);

const corsHeaders = {
  &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
  &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type,Authorization&#39;,
  &#39;Content-Type&#39;: &#39;application/json&#39;,
};

function getUserContext(event: APIGatewayProxyEvent) {
  return {
    userId: event.requestContext.authorizer?.claims?.sub,
    tenantId: event.requestContext.authorizer?.claims?.[&#39;custom:tenant_id&#39;],
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TIMELINE ENDPOINTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// GET /api/thinktank/chats/:chatId/time-machine
export async function getTimeline(event: APIGatewayProxyEvent): Promise&lt;APIGatewayProxyResult&gt; {
  try {
    const { tenantId } = getUserContext(event);
    const chatId = event.pathParameters?.chatId;
    
    if (!chatId) {
      return { statusCode: 400, headers: corsHeaders, body: JSON.stringify({ error: &#39;chatId required&#39; }) };
    }
    
    const timeline = await service.getTimeline(chatId, tenantId);
    
    return {
      statusCode: 200,
      headers: corsHeaders,
      body: JSON.stringify(timeline),
    };
  } catch (error: any) {
    console.error(&#39;getTimeline error:&#39;, error);
    return { statusCode: 500, headers: corsHeaders, body: JSON.stringify({ error: error.message }) };
  }
}

// GET /api/thinktank/chats/:chatId/time-machine/snapshots/:snapshotId
export async function getChatAtSnapshot(event: APIGatewayProxyEvent): Promise&lt;APIGatewayProxyResult&gt; {
  try {
    const { tenantId } = getUserContext(event);
    const chatId = event.pathParameters?.chatId;
    const snapshotId = event.pathParameters?.snapshotId;
    
    if (!chatId || !snapshotId) {
      return { statusCode: 400, headers: corsHeaders, body: JSON.stringify({ error: &#39;chatId and snapshotId required&#39; }) };
    }
    
    const state = await service.getChatAtSnapshot(chatId, snapshotId, tenantId);
    
    return {
      statusCode: 200,
      headers: corsHeaders,
      body: JSON.stringify(state),
    };
  } catch (error: any) {
    console.error(&#39;getChatAtSnapshot error:&#39;, error);
    return { statusCode: 500, headers: corsHeaders, body: JSON.stringify({ error: error.message }) };
  }
}

// GET /api/thinktank/chats/:chatId/time-machine/calendar/:date
export async function getSnapshotsByDate(event: APIGatewayProxyEvent): Promise&lt;APIGatewayProxyResult&gt; {
  try {
    const { tenantId } = getUserContext(event);
    const chatId = event.pathParameters?.chatId;
    const date = event.pathParameters?.date;  // YYYY-MM-DD
    
    if (!chatId || !date) {
      return { statusCode: 400, headers: corsHeaders, body: JSON.stringify({ error: &#39;chatId and date required&#39; }) };
    }
    
    const snapshots = await service.getSnapshotsByDate(chatId, date, tenantId);
    
    return {
      statusCode: 200,
      headers: corsHeaders,
      body: JSON.stringify({ snapshots }),
    };
  } catch (error: any) {
    console.error(&#39;getSnapshotsByDate error:&#39;, error);
    return { statusCode: 500, headers: corsHeaders, body: JSON.stringify({ error: error.message }) };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RESTORE ENDPOINTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// POST /api/thinktank/chats/:chatId/time-machine/restore
export async function restoreFromSnapshot(event: APIGatewayProxyEvent): Promise&lt;APIGatewayProxyResult&gt; {
  try {
    const { userId, tenantId } = getUserContext(event);
    const chatId = event.pathParameters?.chatId;
    const body = JSON.parse(event.body || &#39;{}&#39;);
    
    if (!chatId || !body.snapshotId) {
      return { statusCode: 400, headers: corsHeaders, body: JSON.stringify({ error: &#39;chatId and snapshotId required&#39; }) };
    }
    
    const result = await service.restore({
      chatId,
      targetSnapshotId: body.snapshotId,
      scope: (body.scope || &#39;full_chat&#39;) as RestoreScope,
      messageIds: body.messageIds,
      fileIds: body.fileIds,
      reason: body.reason,
    }, userId, tenantId);
    
    return {
      statusCode: 200,
      headers: corsHeaders,
      body: JSON.stringify(result),
    };
  } catch (error: any) {
    console.error(&#39;restoreFromSnapshot error:&#39;, error);
    return { statusCode: 500, headers: corsHeaders, body: JSON.stringify({ error: error.message }) };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MEDIA VAULT ENDPOINTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// GET /api/thinktank/chats/:chatId/time-machine/files
export async function getFiles(event: APIGatewayProxyEvent): Promise&lt;APIGatewayProxyResult&gt; {
  try {
    const { tenantId } = getUserContext(event);
    const chatId = event.pathParameters?.chatId;
    
    if (!chatId) {
      return { statusCode: 400, headers: corsHeaders, body: JSON.stringify({ error: &#39;chatId required&#39; }) };
    }
    
    const result = await pool.query(`
      SELECT * FROM tm_files_with_versions
      WHERE chat_id = $1
      ORDER BY created_at DESC
    `, [chatId]);
    
    return {
      statusCode: 200,
      headers: corsHeaders,
      body: JSON.stringify({ files: result.rows }),
    };
  } catch (error: any) {
    console.error(&#39;getFiles error:&#39;, error);
    return { statusCode: 500, headers: corsHeaders, body: JSON.stringify({ error: error.message }) };
  }
}

// GET /api/thinktank/chats/:chatId/time-machine/files/:fileName/versions
export async function getFileVersions(event: APIGatewayProxyEvent): Promise&lt;APIGatewayProxyResult&gt; {
  try {
    const { tenantId } = getUserContext(event);
    const chatId = event.pathParameters?.chatId;
    const fileName = decodeURIComponent(event.pathParameters?.fileName || &#39;&#39;);
    
    if (!chatId || !fileName) {
      return { statusCode: 400, headers: corsHeaders, body: JSON.stringify({ error: &#39;chatId and fileName required&#39; }) };
    }
    
    const versions = await service.getFileVersions(chatId, fileName);
    
    return {
      statusCode: 200,
      headers: corsHeaders,
      body: JSON.stringify({ versions }),
    };
  } catch (error: any) {
    console.error(&#39;getFileVersions error:&#39;, error);
    return { statusCode: 500, headers: corsHeaders, body: JSON.stringify({ error: error.message }) };
  }
}

// GET /api/thinktank/files/:fileId/download
export async function downloadFile(event: APIGatewayProxyEvent): Promise&lt;APIGatewayProxyResult&gt; {
  try {
    const fileId = event.pathParameters?.fileId;
    
    if (!fileId) {
      return { statusCode: 400, headers: corsHeaders, body: JSON.stringify({ error: &#39;fileId required&#39; }) };
    }
    
    const url = await service.getFileDownloadUrl(fileId);
    
    return {
      statusCode: 302,
      headers: { ...corsHeaders, Location: url },
      body: &#39;&#39;,
    };
  } catch (error: any) {
    console.error(&#39;downloadFile error:&#39;, error);
    return { statusCode: 500, headers: corsHeaders, body: JSON.stringify({ error: error.message }) };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SEARCH ENDPOINTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// GET /api/thinktank/chats/:chatId/time-machine/search
export async function search(event: APIGatewayProxyEvent): Promise&lt;APIGatewayProxyResult&gt; {
  try {
    const { tenantId } = getUserContext(event);
    const chatId = event.pathParameters?.chatId;
    const query = event.queryStringParameters?.q;
    const type = event.queryStringParameters?.type || &#39;all&#39;;  // &#39;messages&#39;, &#39;files&#39;, &#39;all&#39;
    
    if (!chatId || !query) {
      return { statusCode: 400, headers: corsHeaders, body: JSON.stringify({ error: &#39;chatId and q (query) required&#39; }) };
    }
    
    const results: { messages?: any[]; files?: any[] } = {};
    
    if (type === &#39;all&#39; || type === &#39;messages&#39;) {
      results.messages = await service.searchMessages(chatId, query, tenantId);
    }
    
    if (type === &#39;all&#39; || type === &#39;files&#39;) {
      results.files = await service.searchFiles(chatId, query, tenantId);
    }
    
    return {
      statusCode: 200,
      headers: corsHeaders,
      body: JSON.stringify(results),
    };
  } catch (error: any) {
    console.error(&#39;search error:&#39;, error);
    return { statusCode: 500, headers: corsHeaders, body: JSON.stringify({ error: error.message }) };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXPORT ENDPOINTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// POST /api/thinktank/chats/:chatId/time-machine/export
export async function createExport(event: APIGatewayProxyEvent): Promise&lt;APIGatewayProxyResult&gt; {
  try {
    const { userId, tenantId } = getUserContext(event);
    const chatId = event.pathParameters?.chatId;
    const body = JSON.parse(event.body || &#39;{}&#39;);
    
    if (!chatId) {
      return { statusCode: 400, headers: corsHeaders, body: JSON.stringify({ error: &#39;chatId required&#39; }) };
    }
    
    const bundleId = await service.createExportBundle({
      chatId,
      tenantId,
      userId,
      format: (body.format || &#39;zip&#39;) as ExportFormat,
      includeMedia: body.includeMedia !== false,
      includeVersionHistory: body.includeVersionHistory === true,
      fromSnapshotId: body.fromSnapshotId,
    });
    
    return {
      statusCode: 202,
      headers: corsHeaders,
      body: JSON.stringify({ 
        bundleId,
        status: &#39;pending&#39;,
        message: &#39;Export is being prepared. Check status at /api/thinktank/exports/:bundleId&#39;,
      }),
    };
  } catch (error: any) {
    console.error(&#39;createExport error:&#39;, error);
    return { statusCode: 500, headers: corsHeaders, body: JSON.stringify({ error: error.message }) };
  }
}

// GET /api/thinktank/exports/:bundleId
export async function getExportStatus(event: APIGatewayProxyEvent): Promise&lt;APIGatewayProxyResult&gt; {
  try {
    const bundleId = event.pathParameters?.bundleId;
    
    if (!bundleId) {
      return { statusCode: 400, headers: corsHeaders, body: JSON.stringify({ error: &#39;bundleId required&#39; }) };
    }
    
    const result = await pool.query(`
      SELECT * FROM tm_export_bundles WHERE id = $1
    `, [bundleId]);
    
    if (!result.rows[0]) {
      return { statusCode: 404, headers: corsHeaders, body: JSON.stringify({ error: &#39;Export not found&#39; }) };
    }
    
    const bundle = result.rows[0];
    
    // If ready, generate download URL
    let downloadUrl: string | undefined;
    if (bundle.status === &#39;ready&#39; &amp;&amp; bundle.s3_key) {
      downloadUrl = await service.getFileDownloadUrl(bundle.s3_key);
    }
    
    return {
      statusCode: 200,
      headers: corsHeaders,
      body: JSON.stringify({
        bundleId: bundle.id,
        status: bundle.status,
        format: bundle.format,
        sizeBytes: bundle.size_bytes,
        downloadUrl,
        expiresAt: bundle.expires_at,
        createdAt: bundle.created_at,
        completedAt: bundle.completed_at,
        errorMessage: bundle.error_message,
      }),
    };
  } catch (error: any) {
    console.error(&#39;getExportStatus error:&#39;, error);
    return { statusCode: 500, headers: corsHeaders, body: JSON.stringify({ error: error.message }) };
  }
}</code></pre>
<hr />
<h2 id="api-routes-configuration">32.6 API Routes Configuration</h2>
<pre class="typescript"><code>// packages/functions/src/routes/time-machine.routes.ts

import { Router } from &#39;./router&#39;;
import * as handlers from &#39;../handlers/thinktank/time-machine.handlers&#39;;

export function registerTimeMachineRoutes(router: Router) {
  // Timeline
  router.get(&#39;/api/thinktank/chats/:chatId/time-machine&#39;, handlers.getTimeline);
  router.get(&#39;/api/thinktank/chats/:chatId/time-machine/snapshots/:snapshotId&#39;, handlers.getChatAtSnapshot);
  router.get(&#39;/api/thinktank/chats/:chatId/time-machine/calendar/:date&#39;, handlers.getSnapshotsByDate);
  
  // Restore
  router.post(&#39;/api/thinktank/chats/:chatId/time-machine/restore&#39;, handlers.restoreFromSnapshot);
  
  // Files
  router.get(&#39;/api/thinktank/chats/:chatId/time-machine/files&#39;, handlers.getFiles);
  router.get(&#39;/api/thinktank/chats/:chatId/time-machine/files/:fileName/versions&#39;, handlers.getFileVersions);
  router.get(&#39;/api/thinktank/files/:fileId/download&#39;, handlers.downloadFile);
  
  // Search
  router.get(&#39;/api/thinktank/chats/:chatId/time-machine/search&#39;, handlers.search);
  
  // Export
  router.post(&#39;/api/thinktank/chats/:chatId/time-machine/export&#39;, handlers.createExport);
  router.get(&#39;/api/thinktank/exports/:bundleId&#39;, handlers.getExportStatus);
}</code></pre>
<h1 id="section-1">â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</h1>

  
  <div class="footer">
    RADIANT Documentation | Version 5.52.29 | Generated January 25, 2026
  </div>
</body>
</html>