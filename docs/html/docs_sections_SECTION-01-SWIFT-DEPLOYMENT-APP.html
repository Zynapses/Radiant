<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SECTION 01 SWIFT DEPLOYMENT APP - RADIANT Documentation</title>
  
<style>
@media print {
  body { font-size: 11pt !important; }
  pre { page-break-inside: avoid; }
  h1, h2, h3 { page-break-after: avoid; }
  .no-print { display: none !important; }
}

* { box-sizing: border-box; }

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  line-height: 1.7;
  color: #1d1d1f;
  max-width: 900px;
  margin: 0 auto;
  padding: 40px 30px;
  background: white;
}

h1 {
  color: #1d1d1f;
  border-bottom: 3px solid #0071e3;
  padding-bottom: 12px;
  font-size: 28px;
  margin-top: 0;
}

h2 {
  color: #1d1d1f;
  border-bottom: 1px solid #d2d2d7;
  padding-bottom: 8px;
  font-size: 22px;
  margin-top: 40px;
}

h3 { color: #1d1d1f; font-size: 18px; margin-top: 30px; }
h4 { color: #1d1d1f; font-size: 16px; margin-top: 25px; }

a { color: #0071e3; text-decoration: none; }
a:hover { text-decoration: underline; }

code {
  background: #f5f5f7;
  padding: 2px 6px;
  border-radius: 4px;
  font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
  font-size: 0.9em;
  color: #1d1d1f;
}

pre {
  background: #1d1d1f;
  color: #f5f5f7;
  padding: 20px;
  border-radius: 10px;
  overflow-x: auto;
  font-size: 13px;
  line-height: 1.5;
}

pre code {
  background: transparent;
  padding: 0;
  color: inherit;
}

table {
  width: 100%;
  border-collapse: collapse;
  margin: 20px 0;
  font-size: 14px;
}

th, td {
  border: 1px solid #d2d2d7;
  padding: 12px 15px;
  text-align: left;
}

th {
  background: #0071e3;
  color: white;
  font-weight: 600;
}

tr:nth-child(even) { background: #f5f5f7; }

blockquote {
  border-left: 4px solid #0071e3;
  margin: 20px 0;
  padding: 15px 25px;
  background: #f5f5f7;
  border-radius: 0 8px 8px 0;
}

blockquote p { margin: 0; }

img { max-width: 100%; height: auto; border-radius: 8px; }

hr {
  border: none;
  border-top: 1px solid #d2d2d7;
  margin: 40px 0;
}

ul, ol { padding-left: 25px; }
li { margin: 8px 0; }

.header-bar {
  background: linear-gradient(135deg, #0071e3 0%, #00c6ff 100%);
  color: white;
  padding: 20px 30px;
  margin: -40px -30px 30px -30px;
  border-radius: 0 0 16px 16px;
}

.header-bar h1 {
  color: white;
  border: none;
  margin: 0;
  padding: 0;
}

.header-bar .meta {
  font-size: 13px;
  opacity: 0.9;
  margin-top: 8px;
}

.print-btn {
  position: fixed;
  top: 20px;
  right: 20px;
  background: #0071e3;
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  box-shadow: 0 4px 12px rgba(0,113,227,0.3);
}

.print-btn:hover { background: #0077ed; }

.mermaid {
  background: #f5f5f7;
  padding: 20px;
  border-radius: 10px;
  text-align: center;
  margin: 20px 0;
}

.footer {
  margin-top: 60px;
  padding-top: 20px;
  border-top: 1px solid #d2d2d7;
  color: #86868b;
  font-size: 12px;
  text-align: center;
}
</style>

</head>
<body>
  <button class="print-btn no-print" onclick="window.print()">ğŸ–¨ï¸ Print / Save as PDF</button>
  
  <div class="header-bar">
    <h1>SECTION 01 SWIFT DEPLOYMENT APP</h1>
    <div class="meta">RADIANT v5.52.29 | docs/sections/SECTION-01-SWIFT-DEPLOYMENT-APP.md</div>
  </div>
  
  <h1 id="section-1-foundation-swift-deployment-app-v2.0.0">SECTION 1: FOUNDATION &amp; SWIFT DEPLOYMENT APP (v2.0.0)</h1>
<h1 id="Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢">Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â</h1>
<blockquote>
<p><strong>Dependencies:</strong> Section 0 (Shared Types) <strong>Creates:</strong> Monorepo structure, Swift macOS deployment app</p>
</blockquote>
<h2 id="overview">1.1 OVERVIEW</h2>
<p>This section creates: 1. <strong>Monorepo foundation</strong> - Already partially in Section 0 2. <strong>Swift macOS Deployment App</strong> - Complete GUI for deploying RADIANT</p>
<p>The Swift app is the primary interface for administrators. Users should NEVER need to open a terminal.</p>
<hr />
<h2 id="cdk-infrastructure-package-setup">1.2 CDK INFRASTRUCTURE PACKAGE SETUP</h2>
<p>Since types are now in <span class="citation" data-cites="radiant/shared">@radiant/shared</span>, the infrastructure package imports them:</p>
<h3 id="packagesinfrastructurepackage.json">packages/infrastructure/package.json</h3>
<pre class="json"><code>{
  &quot;name&quot;: &quot;@radiant/infrastructure&quot;,
  &quot;version&quot;: &quot;2.2.0&quot;,
  &quot;private&quot;: true,
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;tsc&quot;,
    &quot;cdk&quot;: &quot;cdk&quot;,
    &quot;synth&quot;: &quot;cdk synth&quot;,
    &quot;deploy&quot;: &quot;cdk deploy&quot;,
    &quot;destroy&quot;: &quot;cdk destroy&quot;
  },
  &quot;dependencies&quot;: {
    &quot;@radiant/shared&quot;: &quot;workspace:*&quot;,
    &quot;aws-cdk-lib&quot;: &quot;^2.120.0&quot;,
    &quot;constructs&quot;: &quot;^10.3.0&quot;,
    &quot;source-map-support&quot;: &quot;^0.5.21&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@types/node&quot;: &quot;^20.10.0&quot;,
    &quot;aws-cdk&quot;: &quot;^2.120.0&quot;,
    &quot;typescript&quot;: &quot;^5.3.0&quot;
  }
}</code></pre>
<h3 id="packagesinfrastructurelibconfigtags.ts">packages/infrastructure/lib/config/tags.ts</h3>
<pre class="typescript"><code>/**
 * CDK-specific tagging utilities
 * Types imported from @radiant/shared
 */

import * as cdk from &#39;aws-cdk-lib&#39;;
import { Construct } from &#39;constructs&#39;;

export interface RadiantTags {
  project: string;
  environment: string;
  appId: string;
  tier: number;
  version?: string;
  costCenter?: string;
}

export function applyTags(scope: Construct, tags: RadiantTags): void {
  cdk.Tags.of(scope).add(&#39;Project&#39;, tags.project);
  cdk.Tags.of(scope).add(&#39;Environment&#39;, tags.environment);
  cdk.Tags.of(scope).add(&#39;AppId&#39;, tags.appId);
  cdk.Tags.of(scope).add(&#39;Tier&#39;, tags.tier.toString());
  cdk.Tags.of(scope).add(&#39;Version&#39;, tags.version || &#39;2.2.0&#39;);
  cdk.Tags.of(scope).add(&#39;ManagedBy&#39;, &#39;CDK&#39;);
  
  if (tags.costCenter) {
    cdk.Tags.of(scope).add(&#39;CostCenter&#39;, tags.costCenter);
  }
}

export function getResourceName(
  appId: string,
  environment: string,
  resource: string,
  suffix?: string
): string {
  const base = \`\${appId}-\${environment}-\${resource}\`;
  return suffix ? \`\${base}-\${suffix}\` : base;
}</code></pre>
<blockquote>
<p><strong>NOTE:</strong> The <code>tiers.ts</code> and <code>regions.ts</code> files are NOT created here. CDK stacks import these directly from <code>@radiant/shared</code>:</p>
<pre class="typescript"><code>import { getTierConfig, TIER_CONFIGS, REGIONS } from &#39;@radiant/shared&#39;;</code></pre>
</blockquote>
<hr />
<h2 id="swift-deployment-app">1.3 SWIFT DEPLOYMENT APP</h2>
<h3 id="ai-implementation-notes">AI Implementation Notes</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SWIFT FILE CREATION ORDER (for AI)                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                  â”‚
â”‚  PHASE 1: Project Setup (create first)                                          â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                         â”‚
â”‚  1. Package.swift (or Xcode project)                                            â”‚
â”‚  2. Info.plist                                                                   â”‚
â”‚  3. RadiantDeployer.entitlements                                                â”‚
â”‚                                                                                  â”‚
â”‚  PHASE 2: Core Files (no dependencies)                                          â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                         â”‚
â”‚  4. RadiantDeployerApp.swift (entry point)                                      â”‚
â”‚  5. Models/ManagedApp.swift                                                      â”‚
â”‚  6. Models/Credentials.swift                                                     â”‚
â”‚  7. Models/Deployment.swift                                                      â”‚
â”‚                                                                                  â”‚
â”‚  PHASE 3: State Management                                                       â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                         â”‚
â”‚  8. AppState.swift (depends on: Models)                                          â”‚
â”‚                                                                                  â”‚
â”‚  PHASE 4: Services (depend on Models)                                           â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                         â”‚
â”‚  9.  Services/CredentialService.swift                                           â”‚
â”‚  10. Services/CDKService.swift                                                   â”‚
â”‚  11. Services/AWSService.swift                                                   â”‚
â”‚  12. Services/APIService.swift                                                   â”‚
â”‚                                                                                  â”‚
â”‚  PHASE 5: Views (depend on AppState, Services)                                  â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                         â”‚
â”‚  13. Views/MainView.swift                                                        â”‚
â”‚  14. Views/AppsView.swift                                                        â”‚
â”‚  15. Views/DeployView.swift                                                      â”‚
â”‚  16. Views/SettingsView.swift                                                    â”‚
â”‚  17. Views/ProvidersView.swift                                                   â”‚
â”‚  18. Views/ModelsView.swift                                                      â”‚
â”‚                                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>
<h3 id="platform-requirements">Platform Requirements</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Platform: macOS 13.0+ (Ventura)                                                â”‚
â”‚  Swift: 5.9+                                                                     â”‚
â”‚  Xcode: 15.0+                                                                    â”‚
â”‚  Architecture: Universal (arm64 + x86_64)                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>
<hr />
<h3 id="radiantdeployerpackage.swift">RadiantDeployer/Package.swift</h3>
<pre class="swift"><code>// swift-tools-version: 5.9
// RADIANT Deployer - macOS Swift Package
// Platform: macOS 13.0+

import PackageDescription

let package = Package(
    name: &quot;RadiantDeployer&quot;,
    platforms: [
        .macOS(.v13)
    ],
    products: [
        .executable(name: &quot;RadiantDeployer&quot;, targets: [&quot;RadiantDeployer&quot;])
    ],
    dependencies: [
        // SQLCipher for encrypted credential storage
        .package(url: &quot;https://github.com/nicklockwood/GRDB.swift.git&quot;, from: &quot;6.24.0&quot;),
    ],
    targets: [
        .executableTarget(
            name: &quot;RadiantDeployer&quot;,
            dependencies: [
                .product(name: &quot;GRDB&quot;, package: &quot;GRDB.swift&quot;),
            ],
            path: &quot;Sources&quot;,
            resources: [
                .copy(&quot;Resources/Infrastructure&quot;),
                .copy(&quot;Resources/NodeRuntime&quot;),
            ]
        ),
        .testTarget(
            name: &quot;RadiantDeployerTests&quot;,
            dependencies: [&quot;RadiantDeployer&quot;],
            path: &quot;Tests&quot;
        ),
    ]
)</code></pre>
<hr />
<h3 id="radiantdeployerinfo.plist">RadiantDeployer/Info.plist</h3>
<pre class="xml"><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
&lt;plist version=&quot;1.0&quot;&gt;
&lt;dict&gt;
    &lt;key&gt;CFBundleDevelopmentRegion&lt;/key&gt;
    &lt;string&gt;en&lt;/string&gt;
    &lt;key&gt;CFBundleExecutable&lt;/key&gt;
    &lt;string&gt;RadiantDeployer&lt;/string&gt;
    &lt;key&gt;CFBundleIconFile&lt;/key&gt;
    &lt;string&gt;AppIcon&lt;/string&gt;
    &lt;key&gt;CFBundleIdentifier&lt;/key&gt;
    &lt;string&gt;com.radiant.deployer&lt;/string&gt;
    &lt;key&gt;CFBundleInfoDictionaryVersion&lt;/key&gt;
    &lt;string&gt;6.0&lt;/string&gt;
    &lt;key&gt;CFBundleName&lt;/key&gt;
    &lt;string&gt;RADIANT Deployer&lt;/string&gt;
    &lt;key&gt;CFBundlePackageType&lt;/key&gt;
    &lt;string&gt;APPL&lt;/string&gt;
    &lt;key&gt;CFBundleShortVersionString&lt;/key&gt;
    &lt;string&gt;4.17.0&lt;/string&gt;
    &lt;key&gt;CFBundleVersion&lt;/key&gt;
    &lt;string&gt;1&lt;/string&gt;
    &lt;key&gt;LSMinimumSystemVersion&lt;/key&gt;
    &lt;string&gt;13.0&lt;/string&gt;
    &lt;key&gt;NSHumanReadableCopyright&lt;/key&gt;
    &lt;string&gt;Copyright Â© 2024 RADIANT. All rights reserved.&lt;/string&gt;
    &lt;key&gt;NSMainStoryboardFile&lt;/key&gt;
    &lt;string&gt;&lt;/string&gt;
    &lt;key&gt;NSPrincipalClass&lt;/key&gt;
    &lt;string&gt;NSApplication&lt;/string&gt;
    &lt;key&gt;LSApplicationCategoryType&lt;/key&gt;
    &lt;string&gt;public.app-category.developer-tools&lt;/string&gt;
&lt;/dict&gt;
&lt;/plist&gt;</code></pre>
<hr />
<h3 id="radiantdeployerradiantdeployer.entitlements">RadiantDeployer/RadiantDeployer.entitlements</h3>
<pre class="xml"><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
&lt;plist version=&quot;1.0&quot;&gt;
&lt;dict&gt;
    &lt;!-- App Sandbox (required for Mac App Store, optional otherwise) --&gt;
    &lt;key&gt;com.apple.security.app-sandbox&lt;/key&gt;
    &lt;false/&gt;
    
    &lt;!-- Network access for AWS API calls --&gt;
    &lt;key&gt;com.apple.security.network.client&lt;/key&gt;
    &lt;true/&gt;
    
    &lt;!-- File access for CDK operations --&gt;
    &lt;key&gt;com.apple.security.files.user-selected.read-write&lt;/key&gt;
    &lt;true/&gt;
    
    &lt;!-- Keychain access for credential storage --&gt;
    &lt;key&gt;com.apple.security.keychain&lt;/key&gt;
    &lt;true/&gt;
    
    &lt;!-- Process execution for CDK/Node commands --&gt;
    &lt;key&gt;com.apple.security.cs.allow-unsigned-executable-memory&lt;/key&gt;
    &lt;true/&gt;
&lt;/dict&gt;
&lt;/plist&gt;</code></pre>
<hr />
<h3 id="radiantdeployerradiantdeployerapp.swift">RadiantDeployer/RadiantDeployerApp.swift</h3>
<pre class="swift"><code>// MARK: - RADIANT Deployer App Entry Point
// Platform: macOS 13.0+
// Swift: 5.9+
// Dependencies: SwiftUI (system), AppState.swift

import SwiftUI

/// Main application entry point for RADIANT Deployer
/// This is the first file Xcode will look for when launching the app
@main
struct RadiantDeployerApp: App {
    // MARK: - State
    
    /// App-lifetime state object - created once, shared across all views
    @StateObject private var appState = AppState()
    
    // MARK: - Body
    
    var body: some Scene {
        WindowGroup {
            MainView()
                .environmentObject(appState)
                .frame(minWidth: 1200, minHeight: 800)
        }
        .windowStyle(.hiddenTitleBar)
        .commands {
            CommandGroup(replacing: .newItem) { }
        }
        
        Settings {
            SettingsView()
                .environmentObject(appState)
        }
    }
}

// MARK: - Preview

#Preview {
    MainView()
        .environmentObject(AppState())
        .frame(width: 1200, height: 800)
}</code></pre>
<h3 id="radiantdeployerappstate.swift">RadiantDeployer/AppState.swift</h3>
<pre class="swift"><code>import SwiftUI
import Combine

@MainActor
final class AppState: ObservableObject {
    // MARK: - Navigation
    @Published var selectedTab: NavigationTab = .apps
    @Published var selectedApp: ManagedApp?
    @Published var selectedEnvironment: Environment = .dev
    
    // MARK: - Data
    @Published var apps: [ManagedApp] = []
    @Published var credentials: [CredentialSet] = []
    @Published var isLoading = false
    @Published var error: AppError?
    
    // MARK: - Deployment
    @Published var isDeploying = false
    @Published var deploymentProgress: DeploymentProgress?
    @Published var deploymentLogs: [LogEntry] = []
    
    // MARK: - Services
    let credentialService = CredentialService()
    let cdkService = CDKService()
    let awsService = AWSService()
    let apiService = APIService()
    
    // MARK: - Initialization
    init() {
        Task {
            await loadInitialData()
        }
    }
    
    func loadInitialData() async {
        isLoading = true
        defer { isLoading = false }
        
        do {
            credentials = try await credentialService.loadCredentials()
            apps = try await loadApps()
        } catch {
            self.error = AppError(message: &quot;Failed to load data&quot;, underlying: error)
        }
    }
    
    private func loadApps() async throws -&gt; [ManagedApp] {
        // Load from local storage or API
        return ManagedApp.defaults
    }
}

// MARK: - Navigation
enum NavigationTab: String, CaseIterable, Identifiable, Sendable {
    case apps = &quot;Apps&quot;
    case deploy = &quot;Deploy&quot;
    case providers = &quot;Providers&quot;
    case models = &quot;Models&quot;
    case settings = &quot;Settings&quot;
    
    var id: String { rawValue }
    
    var icon: String {
        switch self {
        case .apps: return &quot;square.grid.2x2&quot;
        case .deploy: return &quot;arrow.up.circle&quot;
        case .providers: return &quot;building.2&quot;
        case .models: return &quot;cpu&quot;
        case .settings: return &quot;gearshape&quot;
        }
    }
}

// MARK: - Environment
enum Environment: String, CaseIterable, Identifiable, Sendable {
    case dev = &quot;Development&quot;
    case staging = &quot;Staging&quot;
    case prod = &quot;Production&quot;
    
    var id: String { rawValue }
    
    var shortName: String {
        switch self {
        case .dev: return &quot;DEV&quot;
        case .staging: return &quot;STAGING&quot;
        case .prod: return &quot;PROD&quot;
        }
    }
    
    var color: Color {
        switch self {
        case .dev: return .blue
        case .staging: return .orange
        case .prod: return .green
        }
    }
}

// MARK: - Error
struct AppError: Identifiable, Sendable {
    let id = UUID()
    let message: String
    let underlying: (any Error)?
    
    var localizedDescription: String {
        if let underlying = underlying {
            return &quot;\(message): \(underlying.localizedDescription)&quot;
        }
        return message
    }
}</code></pre>
<h3 id="radiantdeployermodelsmanagedapp.swift">RadiantDeployer/Models/ManagedApp.swift</h3>
<pre class="swift"><code>// MARK: - ManagedApp Model
// Platform: macOS 13.0+
// Dependencies: Foundation

import Foundation

// MARK: - Constants

/// Domain placeholder - replace with your actual domain during setup
let DOMAIN_PLACEHOLDER = &quot;YOUR_DOMAIN.com&quot;

// MARK: - ManagedApp

struct ManagedApp: Identifiable, Codable, Hashable, Sendable {
    let id: String
    var name: String
    var domain: String
    var description: String?
    var createdAt: Date
    var updatedAt: Date
    var environments: EnvironmentStatuses
    
    /// Check if domain has been configured
    var isDomainConfigured: Bool {
        !domain.contains(DOMAIN_PLACEHOLDER)
    }
    
    struct EnvironmentStatuses: Codable, Hashable, Sendable {
        var dev: EnvironmentStatus
        var staging: EnvironmentStatus
        var prod: EnvironmentStatus
        
        subscript(env: Environment) -&gt; EnvironmentStatus {
            get {
                switch env {
                case .dev: return dev
                case .staging: return staging
                case .prod: return prod
                }
            }
            set {
                switch env {
                case .dev: dev = newValue
                case .staging: staging = newValue
                case .prod: prod = newValue
                }
            }
        }
    }
}

struct EnvironmentStatus: Codable, Hashable, Sendable {
    var deployed: Bool
    var version: String?
    var tier: Int
    var lastDeployedAt: Date?
    var healthStatus: HealthStatus
    var apiUrl: String?
    var dashboardUrl: String?
}

enum HealthStatus: String, Codable, Sendable {
    case healthy, degraded, unhealthy, unknown
    
    var color: String {
        switch self {
        case .healthy: return &quot;green&quot;
        case .degraded: return &quot;orange&quot;
        case .unhealthy: return &quot;red&quot;
        case .unknown: return &quot;gray&quot;
        }
    }
}

// MARK: - Defaults
extension ManagedApp {
    static let defaults: [ManagedApp] = [
        ManagedApp(
            id: &quot;thinktank&quot;,
            name: &quot;Think Tank&quot;,
            domain: &quot;thinktank.\(DOMAIN_PLACEHOLDER)&quot;,
            description: &quot;AI-powered brainstorming and ideation platform&quot;,
            createdAt: Date(),
            updatedAt: Date(),
            environments: .init(
                dev: .init(deployed: false, tier: 1, healthStatus: .unknown),
                staging: .init(deployed: false, tier: 2, healthStatus: .unknown),
                prod: .init(deployed: false, tier: 3, healthStatus: .unknown)
            )
        ),
        ManagedApp(
            id: &quot;launchboard&quot;,
            name: &quot;Launch Board&quot;,
            domain: &quot;launchboard.\(DOMAIN_PLACEHOLDER)&quot;,
            description: &quot;Project launch management and tracking&quot;,
            createdAt: Date(),
            updatedAt: Date(),
            environments: .init(
                dev: .init(deployed: false, tier: 1, healthStatus: .unknown),
                staging: .init(deployed: false, tier: 2, healthStatus: .unknown),
                prod: .init(deployed: false, tier: 3, healthStatus: .unknown)
            )
        ),
        ManagedApp(
            id: &quot;alwaysme&quot;,
            name: &quot;Always Me&quot;,
            domain: &quot;alwaysme.\(DOMAIN_PLACEHOLDER)&quot;,
            description: &quot;Personal AI assistant and memory&quot;,
            createdAt: Date(),
            updatedAt: Date(),
            environments: .init(
                dev: .init(deployed: false, tier: 1, healthStatus: .unknown),
                staging: .init(deployed: false, tier: 2, healthStatus: .unknown),
                prod: .init(deployed: false, tier: 3, healthStatus: .unknown)
            )
        ),
        ManagedApp(
            id: &quot;mechanicalmaker&quot;,
            name: &quot;Mechanical Maker&quot;,
            domain: &quot;mechanicalmaker.\(DOMAIN_PLACEHOLDER)&quot;,
            description: &quot;AI-assisted mechanical design and CAD&quot;,
            createdAt: Date(),
            updatedAt: Date(),
            environments: .init(
                dev: .init(deployed: false, tier: 1, healthStatus: .unknown),
                staging: .init(deployed: false, tier: 2, healthStatus: .unknown),
                prod: .init(deployed: false, tier: 3, healthStatus: .unknown)
            )
        )
    ]
}</code></pre>
<h3 id="radiantdeployermodelscredentials.swift">RadiantDeployer/Models/Credentials.swift</h3>
<pre class="swift"><code>import Foundation

struct CredentialSet: Identifiable, Codable {
    let id: String
    var name: String
    var accessKeyId: String
    var secretAccessKey: String
    var region: String
    var accountId: String?
    var environment: CredentialEnvironment
    var createdAt: Date
    var lastValidatedAt: Date?
    var isValid: Bool?
    
    var maskedSecretKey: String {
        guard secretAccessKey.count &gt; 8 else { return &quot;********&quot; }
        let prefix = String(secretAccessKey.prefix(4))
        let suffix = String(secretAccessKey.suffix(4))
        return &quot;\(prefix)...\(suffix)&quot;
    }
}

enum CredentialEnvironment: String, Codable, CaseIterable {
    case dev = &quot;Development&quot;
    case staging = &quot;Staging&quot;
    case prod = &quot;Production&quot;
    case shared = &quot;Shared&quot;
}

struct AWSAccount: Codable {
    let accountId: String
    let accountAlias: String?
    let regions: [String]
}</code></pre>
<h3 id="radiantdeployermodelsdeployment.swift">RadiantDeployer/Models/Deployment.swift</h3>
<pre class="swift"><code>import Foundation

// MARK: - Version Constant

/// Current RADIANT version - matches @radiant/shared/constants/version.ts
let RADIANT_VERSION = &quot;4.17.0&quot;

// MARK: - Deployment Progress

struct DeploymentProgress: Identifiable, Sendable {
    let id = UUID()
    var phase: DeploymentPhase
    var progress: Double // 0.0 - 1.0
    var currentStack: String?
    var message: String?
    var startedAt: Date
    var estimatedCompletion: Date?
}

enum DeploymentPhase: String, CaseIterable, Sendable {
    case idle = &quot;Idle&quot;
    case validating = &quot;Validating Credentials&quot;
    case bootstrapping = &quot;Bootstrapping CDK&quot;
    case synthesizing = &quot;Synthesizing Stacks&quot;
    case deployingFoundation = &quot;Deploying Foundation&quot;
    case deployingNetworking = &quot;Deploying Networking&quot;
    case deploySecurity = &quot;Deploying Security&quot;
    case deployingData = &quot;Deploying Data Layer&quot;
    case deployingAI = &quot;Deploying AI Services&quot;
    case deployingAPI = &quot;Deploying API Layer&quot;
    case deployingAdmin = &quot;Deploying Admin Dashboard&quot;
    case runningMigrations = &quot;Running Migrations&quot;
    case seedingData = &quot;Seeding Initial Data&quot;
    case verifying = &quot;Verifying Deployment&quot;
    case complete = &quot;Complete&quot;
    case failed = &quot;Failed&quot;
    
    var progress: Double {
        switch self {
        case .idle: return 0.0
        case .validating: return 0.05
        case .bootstrapping: return 0.10
        case .synthesizing: return 0.15
        case .deployingFoundation: return 0.25
        case .deployingNetworking: return 0.35
        case .deploySecurity: return 0.45
        case .deployingData: return 0.55
        case .deployingAI: return 0.65
        case .deployingAPI: return 0.75
        case .deployingAdmin: return 0.85
        case .runningMigrations: return 0.90
        case .seedingData: return 0.95
        case .verifying: return 0.98
        case .complete: return 1.0
        case .failed: return 0.0
        }
    }
    
    var icon: String {
        switch self {
        case .idle: return &quot;circle&quot;
        case .validating: return &quot;checkmark.shield&quot;
        case .bootstrapping: return &quot;arrow.up.circle&quot;
        case .synthesizing: return &quot;doc.text&quot;
        case .deployingFoundation: return &quot;building&quot;
        case .deployingNetworking: return &quot;network&quot;
        case .deploySecurity: return &quot;lock.shield&quot;
        case .deployingData: return &quot;cylinder&quot;
        case .deployingAI: return &quot;cpu&quot;
        case .deployingAPI: return &quot;server.rack&quot;
        case .deployingAdmin: return &quot;rectangle.3.group&quot;
        case .runningMigrations: return &quot;arrow.triangle.2.circlepath&quot;
        case .seedingData: return &quot;leaf&quot;
        case .verifying: return &quot;checkmark.circle&quot;
        case .complete: return &quot;checkmark.circle.fill&quot;
        case .failed: return &quot;xmark.circle.fill&quot;
        }
    }
}

struct DeploymentResult: Identifiable, Codable, Sendable {
    let id: String
    let appId: String
    let environment: String
    let version: String
    let success: Bool
    let startedAt: Date
    let completedAt: Date
    let outputs: DeploymentOutputs?
    let errors: [String]?
    
    /// Create result with current RADIANT version
    static func create(
        appId: String,
        environment: String,
        success: Bool,
        startedAt: Date,
        outputs: DeploymentOutputs? = nil,
        errors: [String]? = nil
    ) -&gt; DeploymentResult {
        DeploymentResult(
            id: UUID().uuidString,
            appId: appId,
            environment: environment,
            version: RADIANT_VERSION,
            success: success,
            startedAt: startedAt,
            completedAt: Date(),
            outputs: outputs,
            errors: errors
        )
    }
}

struct DeploymentOutputs: Codable, Sendable {
    let apiUrl: String
    let graphqlUrl: String
    let dashboardUrl: String
    let cognitoUserPoolId: String
    let cognitoClientId: String
    let cognitoDomain: String
    let auroraEndpoint: String
    let s3MediaBucket: String
    let cloudfrontDistribution: String
}

struct LogEntry: Identifiable, Sendable {
    let id = UUID()
    let timestamp: Date
    let level: LogLevel
    let message: String
    let metadata: [String: String]?
}

enum LogLevel: String, Sendable {
    case debug, info, warn, error, success
    
    var color: String {
        switch self {
        case .debug: return &quot;gray&quot;
        case .info: return &quot;blue&quot;
        case .warn: return &quot;orange&quot;
        case .error: return &quot;red&quot;
        case .success: return &quot;green&quot;
        }
    }
    
    var icon: String {
        switch self {
        case .debug: return &quot;ant&quot;
        case .info: return &quot;info.circle&quot;
        case .warn: return &quot;exclamationmark.triangle&quot;
        case .error: return &quot;xmark.circle&quot;
        case .success: return &quot;checkmark.circle&quot;
        }
    }
}</code></pre>
<h3 id="radiantdeployerservicescredentialservice.swift">RadiantDeployer/Services/CredentialService.swift</h3>
<pre class="swift"><code>import Foundation
import SQLite3

/// Manages encrypted credential storage using SQLCipher
actor CredentialService {
    private var db: OpaquePointer?
    private let dbPath: URL
    private let encryptionKey: String
    
    init() {
        let appSupport = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!
        let radiantDir = appSupport.appendingPathComponent(&quot;RadiantDeployer&quot;, isDirectory: true)
        
        try? FileManager.default.createDirectory(at: radiantDir, withIntermediateDirectories: true)
        
        dbPath = radiantDir.appendingPathComponent(&quot;credentials.db&quot;)
        
        // In production, derive from macOS Keychain
        encryptionKey = Self.getOrCreateEncryptionKey()
    }
    
    private static func getOrCreateEncryptionKey() -&gt; String {
        let service = &quot;YOUR_ORG_IDENTIFIER.radiant-deployer&quot;
        let account = &quot;db-encryption-key&quot;
        
        // Try to get existing key
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: account,
            kSecReturnData as String: true
        ]
        
        var result: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &amp;result)
        
        if status == errSecSuccess, let data = result as? Data, let key = String(data: data, encoding: .utf8) {
            return key
        }
        
        // Generate new key
        let newKey = UUID().uuidString + UUID().uuidString
        let keyData = newKey.data(using: .utf8)!
        
        let addQuery: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: account,
            kSecValueData as String: keyData,
            kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly
        ]
        
        SecItemAdd(addQuery as CFDictionary, nil)
        
        return newKey
    }
    
    private func openDatabase() throws {
        guard db == nil else { return }
        
        let flags = SQLITE_OPEN_CREATE | SQLITE_OPEN_READWRITE | SQLITE_OPEN_FULLMUTEX
        
        guard sqlite3_open_v2(dbPath.path, &amp;db, flags, nil) == SQLITE_OK else {
            throw CredentialError.databaseOpenFailed
        }
        
        // Set encryption key (SQLCipher)
        let keySQL = &quot;PRAGMA key = &#39;\(encryptionKey)&#39;;&quot;
        guard sqlite3_exec(db, keySQL, nil, nil, nil) == SQLITE_OK else {
            throw CredentialError.encryptionFailed
        }
        
        // Create tables
        let createSQL = &quot;&quot;&quot;
            CREATE TABLE IF NOT EXISTS credentials (
                id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                access_key_id TEXT NOT NULL,
                secret_access_key TEXT NOT NULL,
                region TEXT NOT NULL,
                account_id TEXT,
                environment TEXT NOT NULL,
                created_at TEXT NOT NULL,
                last_validated_at TEXT,
                is_valid INTEGER
            );
        &quot;&quot;&quot;
        
        guard sqlite3_exec(db, createSQL, nil, nil, nil) == SQLITE_OK else {
            throw CredentialError.tableCreationFailed
        }
    }
    
    func loadCredentials() async throws -&gt; [CredentialSet] {
        try openDatabase()
        
        let query = &quot;SELECT * FROM credentials ORDER BY created_at DESC;&quot;
        var statement: OpaquePointer?
        
        guard sqlite3_prepare_v2(db, query, -1, &amp;statement, nil) == SQLITE_OK else {
            throw CredentialError.queryFailed
        }
        
        defer { sqlite3_finalize(statement) }
        
        var credentials: [CredentialSet] = []
        let dateFormatter = ISO8601DateFormatter()
        
        while sqlite3_step(statement) == SQLITE_ROW {
            let id = String(cString: sqlite3_column_text(statement, 0))
            let name = String(cString: sqlite3_column_text(statement, 1))
            let accessKeyId = String(cString: sqlite3_column_text(statement, 2))
            let secretAccessKey = String(cString: sqlite3_column_text(statement, 3))
            let region = String(cString: sqlite3_column_text(statement, 4))
            let accountId = sqlite3_column_text(statement, 5).map { String(cString: $0) }
            let environment = String(cString: sqlite3_column_text(statement, 6))
            let createdAtStr = String(cString: sqlite3_column_text(statement, 7))
            let lastValidatedAtStr = sqlite3_column_text(statement, 8).map { String(cString: $0) }
            let isValid = sqlite3_column_type(statement, 9) != SQLITE_NULL ? sqlite3_column_int(statement, 9) == 1 : nil
            
            credentials.append(CredentialSet(
                id: id,
                name: name,
                accessKeyId: accessKeyId,
                secretAccessKey: secretAccessKey,
                region: region,
                accountId: accountId,
                environment: CredentialEnvironment(rawValue: environment) ?? .shared,
                createdAt: dateFormatter.date(from: createdAtStr) ?? Date(),
                lastValidatedAt: lastValidatedAtStr.flatMap { dateFormatter.date(from: $0) },
                isValid: isValid
            ))
        }
        
        return credentials
    }
    
    func saveCredential(_ credential: CredentialSet) async throws {
        try openDatabase()
        
        let dateFormatter = ISO8601DateFormatter()
        
        let upsertSQL = &quot;&quot;&quot;
            INSERT OR REPLACE INTO credentials 
            (id, name, access_key_id, secret_access_key, region, account_id, environment, created_at, last_validated_at, is_valid)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?);
        &quot;&quot;&quot;
        
        var statement: OpaquePointer?
        guard sqlite3_prepare_v2(db, upsertSQL, -1, &amp;statement, nil) == SQLITE_OK else {
            throw CredentialError.saveFailed
        }
        
        defer { sqlite3_finalize(statement) }
        
        sqlite3_bind_text(statement, 1, credential.id, -1, nil)
        sqlite3_bind_text(statement, 2, credential.name, -1, nil)
        sqlite3_bind_text(statement, 3, credential.accessKeyId, -1, nil)
        sqlite3_bind_text(statement, 4, credential.secretAccessKey, -1, nil)
        sqlite3_bind_text(statement, 5, credential.region, -1, nil)
        
        if let accountId = credential.accountId {
            sqlite3_bind_text(statement, 6, accountId, -1, nil)
        } else {
            sqlite3_bind_null(statement, 6)
        }
        
        sqlite3_bind_text(statement, 7, credential.environment.rawValue, -1, nil)
        sqlite3_bind_text(statement, 8, dateFormatter.string(from: credential.createdAt), -1, nil)
        
        if let lastValidated = credential.lastValidatedAt {
            sqlite3_bind_text(statement, 9, dateFormatter.string(from: lastValidated), -1, nil)
        } else {
            sqlite3_bind_null(statement, 9)
        }
        
        if let isValid = credential.isValid {
            sqlite3_bind_int(statement, 10, isValid ? 1 : 0)
        } else {
            sqlite3_bind_null(statement, 10)
        }
        
        guard sqlite3_step(statement) == SQLITE_DONE else {
            throw CredentialError.saveFailed
        }
    }
    
    func deleteCredential(id: String) async throws {
        try openDatabase()
        
        let deleteSQL = &quot;DELETE FROM credentials WHERE id = ?;&quot;
        var statement: OpaquePointer?
        
        guard sqlite3_prepare_v2(db, deleteSQL, -1, &amp;statement, nil) == SQLITE_OK else {
            throw CredentialError.deleteFailed
        }
        
        defer { sqlite3_finalize(statement) }
        
        sqlite3_bind_text(statement, 1, id, -1, nil)
        
        guard sqlite3_step(statement) == SQLITE_DONE else {
            throw CredentialError.deleteFailed
        }
    }
    
    deinit {
        if db != nil {
            sqlite3_close(db)
        }
    }
}

enum CredentialError: Error, LocalizedError {
    case databaseOpenFailed
    case encryptionFailed
    case tableCreationFailed
    case queryFailed
    case saveFailed
    case deleteFailed
    case validationFailed(String)
    
    var errorDescription: String? {
        switch self {
        case .databaseOpenFailed: return &quot;Failed to open credential database&quot;
        case .encryptionFailed: return &quot;Failed to set database encryption&quot;
        case .tableCreationFailed: return &quot;Failed to create database tables&quot;
        case .queryFailed: return &quot;Failed to query credentials&quot;
        case .saveFailed: return &quot;Failed to save credential&quot;
        case .deleteFailed: return &quot;Failed to delete credential&quot;
        case .validationFailed(let reason): return &quot;Credential validation failed: \(reason)&quot;
        }
    }
}</code></pre>
<h3 id="radiantdeployerservicescdkservice.swift">RadiantDeployer/Services/CDKService.swift</h3>
<pre class="swift"><code>import Foundation
import Combine

/// Manages CDK deployments from bundled infrastructure code
actor CDKService {
    private var currentProcess: Process?
    private let bundledNodePath: URL
    private let bundledInfraPath: URL
    
    init() {
        let bundle = Bundle.main
        bundledNodePath = bundle.resourceURL!.appendingPathComponent(&quot;NodeRuntime/bin/node&quot;)
        bundledInfraPath = bundle.resourceURL!.appendingPathComponent(&quot;Infrastructure&quot;)
    }
    
    func deploy(
        app: ManagedApp,
        environment: Environment,
        credentials: CredentialSet,
        onPhase: @escaping (DeploymentPhase) -&gt; Void,
        onLog: @escaping (LogEntry) -&gt; Void,
        onProgress: @escaping (Double) -&gt; Void
    ) async throws -&gt; DeploymentResult {
        let startTime = Date()
        var outputs: DeploymentOutputs?
        var errors: [String] = []
        
        // Create temporary working directory
        let workDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString)
        try FileManager.default.createDirectory(at: workDir, withIntermediateDirectories: true)
        
        defer {
            try? FileManager.default.removeItem(at: workDir)
        }
        
        // Copy infrastructure to working directory
        let infraWorkDir = workDir.appendingPathComponent(&quot;infrastructure&quot;)
        try FileManager.default.copyItem(at: bundledInfraPath, to: infraWorkDir)
        
        do {
            // Phase 1: Validate credentials
            onPhase(.validating)
            onLog(LogEntry(timestamp: Date(), level: .info, message: &quot;Validating AWS credentials...&quot;, metadata: nil))
            try await validateCredentials(credentials)
            onProgress(0.05)
            onLog(LogEntry(timestamp: Date(), level: .success, message: &quot;Credentials validated for account \(credentials.accountId ?? &quot;unknown&quot;)&quot;, metadata: nil))
            
            // Phase 2: Install dependencies
            onPhase(.bootstrapping)
            onLog(LogEntry(timestamp: Date(), level: .info, message: &quot;Installing CDK dependencies...&quot;, metadata: nil))
            try await runCommand(&quot;npm&quot;, args: [&quot;ci&quot;], in: infraWorkDir, credentials: credentials, onLog: onLog)
            onProgress(0.10)
            
            // Phase 3: Bootstrap CDK
            onLog(LogEntry(timestamp: Date(), level: .info, message: &quot;Bootstrapping CDK...&quot;, metadata: nil))
            try await runCDK(
                command: &quot;bootstrap&quot;,
                args: [&quot;aws://\(credentials.accountId ?? &quot;&quot;)/\(credentials.region)&quot;],
                in: infraWorkDir,
                credentials: credentials,
                context: buildContext(app: app, environment: environment),
                onLog: onLog
            )
            onProgress(0.15)
            
            // Phase 4: Synthesize
            onPhase(.synthesizing)
            onLog(LogEntry(timestamp: Date(), level: .info, message: &quot;Synthesizing CloudFormation templates...&quot;, metadata: nil))
            try await runCDK(
                command: &quot;synth&quot;,
                args: [&quot;--all&quot;],
                in: infraWorkDir,
                credentials: credentials,
                context: buildContext(app: app, environment: environment),
                onLog: onLog
            )
            onProgress(0.20)
            
            // Phase 5-11: Deploy stacks
            let stacks = [
                (&quot;Foundation&quot;, DeploymentPhase.deployingFoundation, 0.30),
                (&quot;Networking&quot;, DeploymentPhase.deployingNetworking, 0.40),
                (&quot;Security&quot;, DeploymentPhase.deploySecurity, 0.50),
                (&quot;Data&quot;, DeploymentPhase.deployingData, 0.60),
                (&quot;AI&quot;, DeploymentPhase.deployingAI, 0.70),
                (&quot;API&quot;, DeploymentPhase.deployingAPI, 0.80),
                (&quot;Admin&quot;, DeploymentPhase.deployingAdmin, 0.90)
            ]
            
            for (stackName, phase, progress) in stacks {
                onPhase(phase)
                onLog(LogEntry(timestamp: Date(), level: .info, message: &quot;Deploying \(stackName) stack...&quot;, metadata: nil))
                
                let stackOutputs = try await runCDK(
                    command: &quot;deploy&quot;,
                    args: [&quot;\(app.id)-\(environment.rawValue)-\(stackName.lowercased())&quot;, &quot;--require-approval=never&quot;, &quot;--outputs-file=outputs.json&quot;],
                    in: infraWorkDir,
                    credentials: credentials,
                    context: buildContext(app: app, environment: environment),
                    onLog: onLog
                )
                
                onProgress(progress)
                onLog(LogEntry(timestamp: Date(), level: .success, message: &quot;\(stackName) stack deployed&quot;, metadata: nil))
            }
            
            // Phase 12: Run migrations
            onPhase(.runningMigrations)
            onLog(LogEntry(timestamp: Date(), level: .info, message: &quot;Running database migrations...&quot;, metadata: nil))
            try await runMigrations(app: app, environment: environment, credentials: credentials, onLog: onLog)
            onProgress(0.95)
            
            // Phase 13: Verify
            onPhase(.verifying)
            onLog(LogEntry(timestamp: Date(), level: .info, message: &quot;Verifying deployment...&quot;, metadata: nil))
            outputs = try await verifyDeployment(app: app, environment: environment, workDir: infraWorkDir)
            onProgress(1.0)
            
            onPhase(.complete)
            onLog(LogEntry(timestamp: Date(), level: .success, message: &quot;Deployment complete!&quot;, metadata: nil))
            
        } catch {
            errors.append(error.localizedDescription)
            onPhase(.failed)
            onLog(LogEntry(timestamp: Date(), level: .error, message: &quot;Deployment failed: \(error.localizedDescription)&quot;, metadata: nil))
        }
        
        return DeploymentResult.create(
            appId: app.id,
            environment: environment.rawValue,
            success: errors.isEmpty,
            startedAt: startTime,
            outputs: outputs,
            errors: errors.isEmpty ? nil : errors
        )
    }
    
    private func validateCredentials(_ credentials: CredentialSet) async throws {
        // Find AWS CLI - check multiple locations for compatibility
        let awsPaths = [
            &quot;/opt/homebrew/bin/aws&quot;,      // Homebrew on Apple Silicon
            &quot;/usr/local/bin/aws&quot;,          // Homebrew on Intel
            &quot;/usr/bin/aws&quot;,                // System install
        ]
        
        guard let awsPath = awsPaths.first(where: { FileManager.default.fileExists(atPath: $0) }) else {
            throw DeploymentError.awsCliNotFound
        }
        
        let process = Process()
        process.executableURL = URL(fileURLWithPath: awsPath)
        process.arguments = [&quot;sts&quot;, &quot;get-caller-identity&quot;]
        process.environment = buildAWSEnvironment(credentials)
        
        let pipe = Pipe()
        process.standardOutput = pipe
        process.standardError = pipe
        
        try process.run()
        process.waitUntilExit()
        
        guard process.terminationStatus == 0 else {
            throw DeploymentError.credentialValidationFailed
        }
    }
    
    private func runCommand(
        _ command: String,
        args: [String],
        in directory: URL,
        credentials: CredentialSet,
        onLog: @escaping (LogEntry) -&gt; Void
    ) async throws {
        let process = Process()
        process.executableURL = URL(fileURLWithPath: &quot;/usr/bin/env&quot;)
        process.arguments = [command] + args
        process.currentDirectoryURL = directory
        process.environment = buildAWSEnvironment(credentials)
        
        let pipe = Pipe()
        process.standardOutput = pipe
        process.standardError = pipe
        
        pipe.fileHandleForReading.readabilityHandler = { handle in
            let data = handle.availableData
            if let output = String(data: data, encoding: .utf8), !output.isEmpty {
                onLog(LogEntry(timestamp: Date(), level: .debug, message: output.trimmingCharacters(in: .whitespacesAndNewlines), metadata: nil))
            }
        }
        
        try process.run()
        process.waitUntilExit()
        
        pipe.fileHandleForReading.readabilityHandler = nil
        
        guard process.terminationStatus == 0 else {
            throw DeploymentError.commandFailed(command, Int(process.terminationStatus))
        }
    }
    
    @discardableResult
    private func runCDK(
        command: String,
        args: [String],
        in directory: URL,
        credentials: CredentialSet,
        context: [String: String],
        onLog: @escaping (LogEntry) -&gt; Void
    ) async throws -&gt; [String: Any]? {
        var allArgs = [command] + args
        
        for (key, value) in context {
            allArgs.append(&quot;--context&quot;)
            allArgs.append(&quot;\(key)=\(value)&quot;)
        }
        
        try await runCommand(&quot;npx&quot;, args: [&quot;cdk&quot;] + allArgs, in: directory, credentials: credentials, onLog: onLog)
        
        // Read outputs if available
        let outputsFile = directory.appendingPathComponent(&quot;outputs.json&quot;)
        if FileManager.default.fileExists(atPath: outputsFile.path),
           let data = try? Data(contentsOf: outputsFile),
           let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
            return json
        }
        
        return nil
    }
    
    private func buildContext(app: ManagedApp, environment: Environment) -&gt; [String: String] {
        let tier = app.environments[environment].tier
        return [
            &quot;appId&quot;: app.id,
            &quot;appName&quot;: app.name,
            &quot;domain&quot;: app.domain,
            &quot;environment&quot;: environment.rawValue.lowercased(),
            &quot;tier&quot;: String(tier)
        ]
    }
    
    private func buildAWSEnvironment(_ credentials: CredentialSet) -&gt; [String: String] {
        var env = ProcessInfo.processInfo.environment
        env[&quot;AWS_ACCESS_KEY_ID&quot;] = credentials.accessKeyId
        env[&quot;AWS_SECRET_ACCESS_KEY&quot;] = credentials.secretAccessKey
        env[&quot;AWS_DEFAULT_REGION&quot;] = credentials.region
        env[&quot;AWS_REGION&quot;] = credentials.region
        return env
    }
    
    private func runMigrations(
        app: ManagedApp,
        environment: Environment,
        credentials: CredentialSet,
        onLog: @escaping (LogEntry) -&gt; Void
    ) async throws {
        // Invoke migration Lambda
        onLog(LogEntry(timestamp: Date(), level: .info, message: &quot;Invoking migration Lambda...&quot;, metadata: nil))
        // Implementation depends on how migrations are structured
    }
    
    private func verifyDeployment(
        app: ManagedApp,
        environment: Environment,
        workDir: URL
    ) async throws -&gt; DeploymentOutputs {
        // Read outputs from CDK deployment
        let outputsFile = workDir.appendingPathComponent(&quot;outputs.json&quot;)
        
        guard FileManager.default.fileExists(atPath: outputsFile.path),
              let data = try? Data(contentsOf: outputsFile),
              let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            throw DeploymentError.outputsNotFound
        }
        
        // Parse outputs (structure depends on CDK output format)
        // This is a simplified version
        return DeploymentOutputs(
            apiUrl: json[&quot;ApiUrl&quot;] as? String ?? &quot;&quot;,
            graphqlUrl: json[&quot;GraphQLUrl&quot;] as? String ?? &quot;&quot;,
            dashboardUrl: json[&quot;DashboardUrl&quot;] as? String ?? &quot;&quot;,
            cognitoUserPoolId: json[&quot;CognitoUserPoolId&quot;] as? String ?? &quot;&quot;,
            cognitoClientId: json[&quot;CognitoClientId&quot;] as? String ?? &quot;&quot;,
            cognitoDomain: json[&quot;CognitoDomain&quot;] as? String ?? &quot;&quot;,
            auroraEndpoint: json[&quot;AuroraEndpoint&quot;] as? String ?? &quot;&quot;,
            s3MediaBucket: json[&quot;S3MediaBucket&quot;] as? String ?? &quot;&quot;,
            cloudfrontDistribution: json[&quot;CloudFrontDistribution&quot;] as? String ?? &quot;&quot;
        )
    }
    
    func cancel() {
        currentProcess?.terminate()
    }
}

enum DeploymentError: Error, LocalizedError {
    case credentialValidationFailed
    case commandFailed(String, Int)
    case outputsNotFound
    case verificationFailed(String)
    case awsCliNotFound
    case nodeNotFound
    case cdkBootstrapFailed
    
    var errorDescription: String? {
        switch self {
        case .credentialValidationFailed:
            return &quot;AWS credential validation failed&quot;
        case .commandFailed(let cmd, let code):
            return &quot;Command &#39;\(cmd)&#39; failed with exit code \(code)&quot;
        case .outputsNotFound:
            return &quot;Deployment outputs not found&quot;
        case .verificationFailed(let reason):
            return &quot;Deployment verification failed: \(reason)&quot;
        case .awsCliNotFound:
            return &quot;AWS CLI not found. Install via: brew install awscli&quot;
        case .nodeNotFound:
            return &quot;Node.js not found in bundled resources&quot;
        case .cdkBootstrapFailed:
            return &quot;CDK bootstrap failed. Check AWS permissions.&quot;
        }
    }
}</code></pre>
<h3 id="radiantdeployerservicesawsservice.swift">RadiantDeployer/Services/AWSService.swift</h3>
<pre class="swift"><code>import Foundation

/// Direct AWS API interactions (for validation, health checks, etc.)
actor AWSService {
    
    func validateCredentials(_ credentials: CredentialSet) async throws -&gt; AWSAccount {
        let process = Process()
        process.executableURL = URL(fileURLWithPath: &quot;/usr/local/bin/aws&quot;)
        process.arguments = [&quot;sts&quot;, &quot;get-caller-identity&quot;, &quot;--output&quot;, &quot;json&quot;]
        
        var env = ProcessInfo.processInfo.environment
        env[&quot;AWS_ACCESS_KEY_ID&quot;] = credentials.accessKeyId
        env[&quot;AWS_SECRET_ACCESS_KEY&quot;] = credentials.secretAccessKey
        env[&quot;AWS_DEFAULT_REGION&quot;] = credentials.region
        process.environment = env
        
        let pipe = Pipe()
        process.standardOutput = pipe
        process.standardError = Pipe()
        
        try process.run()
        process.waitUntilExit()
        
        guard process.terminationStatus == 0 else {
            throw AWSError.credentialValidationFailed
        }
        
        let data = pipe.fileHandleForReading.readDataToEndOfFile()
        guard let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
              let accountId = json[&quot;Account&quot;] as? String else {
            throw AWSError.invalidResponse
        }
        
        // Get account alias
        let alias = try? await getAccountAlias(credentials: credentials)
        
        return AWSAccount(
            accountId: accountId,
            accountAlias: alias,
            regions: [&quot;us-east-1&quot;, &quot;us-west-2&quot;, &quot;eu-west-1&quot;] // Could be dynamic
        )
    }
    
    private func getAccountAlias(credentials: CredentialSet) async throws -&gt; String? {
        let process = Process()
        process.executableURL = URL(fileURLWithPath: &quot;/usr/local/bin/aws&quot;)
        process.arguments = [&quot;iam&quot;, &quot;list-account-aliases&quot;, &quot;--output&quot;, &quot;json&quot;]
        
        var env = ProcessInfo.processInfo.environment
        env[&quot;AWS_ACCESS_KEY_ID&quot;] = credentials.accessKeyId
        env[&quot;AWS_SECRET_ACCESS_KEY&quot;] = credentials.secretAccessKey
        env[&quot;AWS_DEFAULT_REGION&quot;] = credentials.region
        process.environment = env
        
        let pipe = Pipe()
        process.standardOutput = pipe
        process.standardError = Pipe()
        
        try process.run()
        process.waitUntilExit()
        
        guard process.terminationStatus == 0 else { return nil }
        
        let data = pipe.fileHandleForReading.readDataToEndOfFile()
        guard let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
              let aliases = json[&quot;AccountAliases&quot;] as? [String],
              let alias = aliases.first else {
            return nil
        }
        
        return alias
    }
    
    func checkHealth(app: ManagedApp, environment: Environment, credentials: CredentialSet) async throws -&gt; HealthStatus {
        // Check API Gateway health endpoint
        guard let apiUrl = app.environments[environment].apiUrl else {
            return .unknown
        }
        
        guard let url = URL(string: &quot;\(apiUrl)/health&quot;) else {
            return .unknown
        }
        
        var request = URLRequest(url: url)
        request.timeoutInterval = 10
        
        do {
            let (_, response) = try await URLSession.shared.data(for: request)
            guard let httpResponse = response as? HTTPURLResponse else {
                return .unknown
            }
            
            switch httpResponse.statusCode {
            case 200: return .healthy
            case 503: return .degraded
            default: return .unhealthy
            }
        } catch {
            return .unhealthy
        }
    }
}

enum AWSError: Error, LocalizedError {
    case credentialValidationFailed
    case invalidResponse
    case apiError(String)
    
    var errorDescription: String? {
        switch self {
        case .credentialValidationFailed:
            return &quot;AWS credential validation failed&quot;
        case .invalidResponse:
            return &quot;Invalid response from AWS&quot;
        case .apiError(let message):
            return &quot;AWS API error: \(message)&quot;
        }
    }
}</code></pre>
<h3 id="radiantdeployerservicesapiservice.swift">RadiantDeployer/Services/APIService.swift</h3>
<pre class="swift"><code>import Foundation

/// Communicates with deployed RADIANT APIs
actor APIService {
    private let session = URLSession.shared
    private var authToken: String?
    
    func setAuthToken(_ token: String) {
        self.authToken = token
    }
    
    func fetchProviders(baseUrl: String) async throws -&gt; [Provider] {
        let url = URL(string: &quot;\(baseUrl)/api/v2/providers&quot;)!
        return try await fetch(url: url)
    }
    
    func fetchModels(baseUrl: String) async throws -&gt; [Model] {
        let url = URL(string: &quot;\(baseUrl)/api/v2/models&quot;)!
        return try await fetch(url: url)
    }
    
    private func fetch&lt;T: Decodable&gt;(url: URL) async throws -&gt; T {
        var request = URLRequest(url: url)
        request.setValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
        
        if let token = authToken {
            request.setValue(&quot;Bearer \(token)&quot;, forHTTPHeaderField: &quot;Authorization&quot;)
        }
        
        let (data, response) = try await session.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse,
              (200...299).contains(httpResponse.statusCode) else {
            throw APIError.requestFailed
        }
        
        return try JSONDecoder().decode(T.self, from: data)
    }
}

// Placeholder types for API responses
struct Provider: Codable, Identifiable {
    let id: String
    let name: String
    let status: String
}

struct Model: Codable, Identifiable {
    let id: String
    let name: String
    let providerId: String
}

enum APIError: Error {
    case requestFailed
    case decodingFailed
}</code></pre>
<hr />
<h2 id="part-4-swift-views">PART 4: SWIFT VIEWS</h2>
<h3 id="radiantdeployerviewsmainview.swift">RadiantDeployer/Views/MainView.swift</h3>
<pre class="swift"><code>import SwiftUI

struct MainView: View {
    @EnvironmentObject var appState: AppState
    
    var body: some View {
        NavigationSplitView {
            Sidebar()
        } detail: {
            DetailView()
        }
        .navigationSplitViewStyle(.balanced)
        .alert(item: $appState.error) { error in
            Alert(
                title: Text(&quot;Error&quot;),
                message: Text(error.localizedDescription),
                dismissButton: .default(Text(&quot;OK&quot;))
            )
        }
    }
}

struct Sidebar: View {
    @EnvironmentObject var appState: AppState
    
    var body: some View {
        List(selection: $appState.selectedTab) {
            Section(&quot;Navigation&quot;) {
                ForEach(NavigationTab.allCases) { tab in
                    Label(tab.rawValue, systemImage: tab.icon)
                        .tag(tab)
                }
            }
            
            if !appState.apps.isEmpty {
                Section(&quot;Apps&quot;) {
                    ForEach(appState.apps) { app in
                        AppRow(app: app)
                    }
                }
            }
        }
        .listStyle(.sidebar)
        .frame(minWidth: 220)
        .toolbar {
            ToolbarItem(placement: .automatic) {
                Button(action: { /* Add app */ }) {
                    Image(systemName: &quot;plus&quot;)
                }
            }
        }
    }
}

struct AppRow: View {
    @EnvironmentObject var appState: AppState
    let app: ManagedApp
    
    var body: some View {
        HStack {
            VStack(alignment: .leading, spacing: 2) {
                Text(app.name)
                    .font(.headline)
                Text(app.domain)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
            
            HStack(spacing: 4) {
                EnvironmentDot(status: app.environments.dev)
                EnvironmentDot(status: app.environments.staging)
                EnvironmentDot(status: app.environments.prod)
            }
        }
        .padding(.vertical, 4)
        .contentShape(Rectangle())
        .onTapGesture {
            appState.selectedApp = app
            appState.selectedTab = .deploy
        }
    }
}

struct EnvironmentDot: View {
    let status: EnvironmentStatus
    
    var body: some View {
        Circle()
            .fill(status.deployed ? Color(status.healthStatus.color) : Color.gray.opacity(0.3))
            .frame(width: 8, height: 8)
    }
}

struct DetailView: View {
    @EnvironmentObject var appState: AppState
    
    var body: some View {
        Group {
            switch appState.selectedTab {
            case .apps:
                AppsView()
            case .deploy:
                DeployView()
            case .providers:
                ProvidersView()
            case .models:
                ModelsView()
            case .settings:
                SettingsView()
            }
        }
    }
}</code></pre>
<h3 id="radiantdeployerviewsappsview.swift">RadiantDeployer/Views/AppsView.swift</h3>
<pre class="swift"><code>import SwiftUI

struct AppsView: View {
    @EnvironmentObject var appState: AppState
    @State private var showingAddApp = false
    
    var body: some View {
        ScrollView {
            LazyVGrid(columns: [GridItem(.adaptive(minimum: 300))], spacing: 20) {
                ForEach(appState.apps) { app in
                    AppCard(app: app)
                }
                
                AddAppCard(action: { showingAddApp = true })
            }
            .padding()
        }
        .navigationTitle(&quot;Applications&quot;)
        .sheet(isPresented: $showingAddApp) {
            AddAppSheet()
        }
    }
}

struct AppCard: View {
    @EnvironmentObject var appState: AppState
    let app: ManagedApp
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            HStack {
                VStack(alignment: .leading) {
                    Text(app.name)
                        .font(.title2)
                        .fontWeight(.semibold)
                    Text(app.domain)
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
                
                Spacer()
                
                Menu {
                    Button(&quot;Edit&quot;) { }
                    Button(&quot;View Logs&quot;) { }
                    Divider()
                    Button(&quot;Delete&quot;, role: .destructive) { }
                } label: {
                    Image(systemName: &quot;ellipsis.circle&quot;)
                        .font(.title3)
                }
            }
            
            Divider()
            
            HStack(spacing: 20) {
                EnvironmentStatusView(name: &quot;DEV&quot;, status: app.environments.dev, color: .blue)
                EnvironmentStatusView(name: &quot;STAGING&quot;, status: app.environments.staging, color: .orange)
                EnvironmentStatusView(name: &quot;PROD&quot;, status: app.environments.prod, color: .green)
            }
            
            HStack {
                Button(&quot;Deploy&quot;) {
                    appState.selectedApp = app
                    appState.selectedTab = .deploy
                }
                .buttonStyle(.borderedProminent)
                
                Button(&quot;Dashboard&quot;) {
                    if let url = URL(string: app.environments.prod.dashboardUrl ?? &quot;&quot;) {
                        NSWorkspace.shared.open(url)
                    }
                }
                .buttonStyle(.bordered)
                .disabled(app.environments.prod.dashboardUrl == nil)
            }
        }
        .padding()
        .background(Color(.windowBackgroundColor))
        .cornerRadius(12)
        .shadow(radius: 2)
    }
}

struct EnvironmentStatusView: View {
    let name: String
    let status: EnvironmentStatus
    let color: Color
    
    var body: some View {
        VStack(spacing: 4) {
            Text(name)
                .font(.caption)
                .fontWeight(.medium)
                .foregroundColor(.secondary)
            
            Circle()
                .fill(status.deployed ? Color(status.healthStatus.color) : Color.gray.opacity(0.3))
                .frame(width: 12, height: 12)
            
            if status.deployed, let version = status.version {
                Text(&quot;v\(version)&quot;)
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
        }
    }
}

struct AddAppCard: View {
    let action: () -&gt; Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 12) {
                Image(systemName: &quot;plus.circle&quot;)
                    .font(.system(size: 40))
                    .foregroundColor(.accentColor)
                Text(&quot;Add Application&quot;)
                    .font(.headline)
            }
            .frame(maxWidth: .infinity, minHeight: 150)
            .background(Color(.windowBackgroundColor).opacity(0.5))
            .cornerRadius(12)
            .overlay(
                RoundedRectangle(cornerRadius: 12)
                    .stroke(style: StrokeStyle(lineWidth: 2, dash: [8]))
                    .foregroundColor(.secondary.opacity(0.3))
            )
        }
        .buttonStyle(.plain)
    }
}

struct AddAppSheet: View {
    @Environment(\.dismiss) var dismiss
    @State private var appId = &quot;&quot;
    @State private var appName = &quot;&quot;
    @State private var domain = &quot;&quot;
    
    var body: some View {
        VStack(spacing: 20) {
            Text(&quot;Add New Application&quot;)
                .font(.title2)
                .fontWeight(.semibold)
            
            Form {
                TextField(&quot;App ID (lowercase, no spaces)&quot;, text: $appId)
                TextField(&quot;App Name&quot;, text: $appName)
                TextField(&quot;Domain (e.g., myapp.YOUR_DOMAIN.com)&quot;, text: $domain)
            }
            .formStyle(.grouped)
            
            HStack {
                Button(&quot;Cancel&quot;) { dismiss() }
                    .buttonStyle(.bordered)
                
                Button(&quot;Add Application&quot;) {
                    // Add app logic
                    dismiss()
                }
                .buttonStyle(.borderedProminent)
                .disabled(appId.isEmpty || appName.isEmpty || domain.isEmpty)
            }
        }
        .padding()
        .frame(width: 400)
    }
}</code></pre>
<h3 id="radiantdeployerviewsdeployview.swift">RadiantDeployer/Views/DeployView.swift</h3>
<pre class="swift"><code>import SwiftUI

struct DeployView: View {
    @EnvironmentObject var appState: AppState
    @State private var selectedCredential: CredentialSet?
    
    var body: some View {
        HSplitView {
            // Left: Configuration
            DeployConfigPanel(selectedCredential: $selectedCredential)
                .frame(minWidth: 350, maxWidth: 450)
            
            // Right: Logs
            DeployLogPanel()
                .frame(minWidth: 500)
        }
        .navigationTitle(&quot;Deploy&quot;)
    }
}

struct DeployConfigPanel: View {
    @EnvironmentObject var appState: AppState
    @Binding var selectedCredential: CredentialSet?
    @State private var selectedTier: Int = 1
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 24) {
                // App Selection
                Section {
                    Picker(&quot;Application&quot;, selection: $appState.selectedApp) {
                        Text(&quot;Select an app&quot;).tag(nil as ManagedApp?)
                        ForEach(appState.apps) { app in
                            Text(app.name).tag(app as ManagedApp?)
                        }
                    }
                    .pickerStyle(.menu)
                } header: {
                    Text(&quot;Application&quot;)
                        .font(.headline)
                }
                
                // Environment Selection
                Section {
                    Picker(&quot;Environment&quot;, selection: $appState.selectedEnvironment) {
                        ForEach(Environment.allCases) { env in
                            HStack {
                                Circle()
                                    .fill(env.color)
                                    .frame(width: 8, height: 8)
                                Text(env.rawValue)
                            }
                            .tag(env)
                        }
                    }
                    .pickerStyle(.segmented)
                } header: {
                    Text(&quot;Environment&quot;)
                        .font(.headline)
                }
                
                // Credentials
                Section {
                    Picker(&quot;AWS Credentials&quot;, selection: $selectedCredential) {
                        Text(&quot;Select credentials&quot;).tag(nil as CredentialSet?)
                        ForEach(appState.credentials) { cred in
                            Text(&quot;\(cred.name) (\(cred.environment.rawValue))&quot;)
                                .tag(cred as CredentialSet?)
                        }
                    }
                    .pickerStyle(.menu)
                    
                    if let cred = selectedCredential {
                        HStack {
                            Label(cred.region, systemImage: &quot;globe&quot;)
                            Spacer()
                            if let valid = cred.isValid {
                                Image(systemName: valid ? &quot;checkmark.circle.fill&quot; : &quot;xmark.circle.fill&quot;)
                                    .foregroundColor(valid ? .green : .red)
                            }
                        }
                        .font(.caption)
                        .foregroundColor(.secondary)
                    }
                    
                    Button(&quot;Manage Credentials&quot;) {
                        appState.selectedTab = .settings
                    }
                    .font(.caption)
                } header: {
                    Text(&quot;AWS Credentials&quot;)
                        .font(.headline)
                }
                
                // Tier Selection
                Section {
                    Picker(&quot;Infrastructure Tier&quot;, selection: $selectedTier) {
                        Text(&quot;1 - SEED (Development)&quot;).tag(1)
                        Text(&quot;2 - STARTUP (Small Production)&quot;).tag(2)
                        Text(&quot;3 - GROWTH (Medium Production)&quot;).tag(3)
                        Text(&quot;4 - SCALE (Large + Multi-Region)&quot;).tag(4)
                        Text(&quot;5 - ENTERPRISE (Full Compliance)&quot;).tag(5)
                    }
                    .pickerStyle(.menu)
                } header: {
                    Text(&quot;Infrastructure Tier&quot;)
                        .font(.headline)
                }
                
                Divider()
                
                // Deploy Button
                Button(action: startDeployment) {
                    HStack {
                        if appState.isDeploying {
                            ProgressView()
                                .scaleEffect(0.8)
                        } else {
                            Image(systemName: &quot;arrow.up.circle.fill&quot;)
                        }
                        Text(appState.isDeploying ? &quot;Deploying...&quot; : &quot;Deploy&quot;)
                    }
                    .frame(maxWidth: .infinity)
                }
                .buttonStyle(.borderedProminent)
                .controlSize(.large)
                .disabled(!canDeploy)
                
                // Progress
                if let progress = appState.deploymentProgress {
                    VStack(alignment: .leading, spacing: 8) {
                        HStack {
                            Image(systemName: progress.phase.icon)
                            Text(progress.phase.rawValue)
                            Spacer()
                            Text(&quot;\(Int(progress.progress * 100))%&quot;)
                        }
                        .font(.subheadline)
                        
                        ProgressView(value: progress.progress)
                    }
                    .padding()
                    .background(Color(.textBackgroundColor))
                    .cornerRadius(8)
                }
            }
            .padding()
        }
    }
    
    private var canDeploy: Bool {
        appState.selectedApp != nil &amp;&amp;
        selectedCredential != nil &amp;&amp;
        !appState.isDeploying
    }
    
    private func startDeployment() {
        guard let app = appState.selectedApp,
              let credentials = selectedCredential else { return }
        
        appState.isDeploying = true
        appState.deploymentLogs = []
        
        Task {
            let result = try await appState.cdkService.deploy(
                app: app,
                environment: appState.selectedEnvironment,
                credentials: credentials,
                onPhase: { phase in
                    Task { @MainActor in
                        appState.deploymentProgress = DeploymentProgress(
                            phase: phase,
                            progress: phase.progress,
                            currentStack: nil,
                            message: nil,
                            startedAt: Date()
                        )
                    }
                },
                onLog: { log in
                    Task { @MainActor in
                        appState.deploymentLogs.append(log)
                    }
                },
                onProgress: { progress in
                    Task { @MainActor in
                        appState.deploymentProgress?.progress = progress
                    }
                }
            )
            
            await MainActor.run {
                appState.isDeploying = false
                
                if result.success {
                    // Update app status
                    if let index = appState.apps.firstIndex(where: { $0.id == app.id }) {
                        appState.apps[index].environments[appState.selectedEnvironment].deployed = true
                        appState.apps[index].environments[appState.selectedEnvironment].version = result.version
                        appState.apps[index].environments[appState.selectedEnvironment].healthStatus = .healthy
                        appState.apps[index].environments[appState.selectedEnvironment].apiUrl = result.outputs?.apiUrl
                        appState.apps[index].environments[appState.selectedEnvironment].dashboardUrl = result.outputs?.dashboardUrl
                    }
                }
            }
        }
    }
}

struct DeployLogPanel: View {
    @EnvironmentObject var appState: AppState
    
    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            HStack {
                Text(&quot;Deployment Logs&quot;)
                    .font(.headline)
                Spacer()
                Button(action: { appState.deploymentLogs = [] }) {
                    Image(systemName: &quot;trash&quot;)
                }
                .buttonStyle(.borderless)
                .disabled(appState.deploymentLogs.isEmpty)
            }
            .padding()
            
            Divider()
            
            ScrollViewReader { proxy in
                ScrollView {
                    LazyVStack(alignment: .leading, spacing: 4) {
                        ForEach(appState.deploymentLogs) { log in
                            LogRow(log: log)
                                .id(log.id)
                        }
                    }
                    .padding()
                }
                .onChange(of: appState.deploymentLogs.count) { _ in
                    if let lastLog = appState.deploymentLogs.last {
                        withAnimation {
                            proxy.scrollTo(lastLog.id, anchor: .bottom)
                        }
                    }
                }
            }
            .background(Color(.textBackgroundColor))
        }
    }
}

struct LogRow: View {
    let log: LogEntry
    
    private var timeString: String {
        let formatter = DateFormatter()
        formatter.dateFormat = &quot;HH:mm:ss.SSS&quot;
        return formatter.string(from: log.timestamp)
    }
    
    var body: some View {
        HStack(alignment: .top, spacing: 8) {
            Text(timeString)
                .font(.system(.caption, design: .monospaced))
                .foregroundColor(.secondary)
            
            Image(systemName: log.level.icon)
                .foregroundColor(Color(log.level.color))
                .font(.caption)
            
            Text(log.message)
                .font(.system(.caption, design: .monospaced))
                .foregroundColor(Color(log.level.color))
                .textSelection(.enabled)
        }
    }
}</code></pre>
<h3 id="radiantdeployerviewssettingsview.swift">RadiantDeployer/Views/SettingsView.swift</h3>
<pre class="swift"><code>import SwiftUI

struct SettingsView: View {
    @EnvironmentObject var appState: AppState
    
    var body: some View {
        TabView {
            CredentialsSettingsView()
                .tabItem {
                    Label(&quot;Credentials&quot;, systemImage: &quot;key&quot;)
                }
            
            GeneralSettingsView()
                .tabItem {
                    Label(&quot;General&quot;, systemImage: &quot;gearshape&quot;)
                }
            
            AboutView()
                .tabItem {
                    Label(&quot;About&quot;, systemImage: &quot;info.circle&quot;)
                }
        }
        .padding()
    }
}

struct CredentialsSettingsView: View {
    @EnvironmentObject var appState: AppState
    @State private var showingAddCredential = false
    @State private var selectedCredential: CredentialSet?
    @State private var isValidating = false
    
    var body: some View {
        VStack(alignment: .leading, spacing: 20) {
            HStack {
                Text(&quot;AWS Credentials&quot;)
                    .font(.title2)
                    .fontWeight(.semibold)
                
                Spacer()
                
                Button(action: { showingAddCredential = true }) {
                    Label(&quot;Add Credential&quot;, systemImage: &quot;plus&quot;)
                }
                .buttonStyle(.borderedProminent)
            }
            
            List(selection: $selectedCredential) {
                ForEach(appState.credentials) { credential in
                    CredentialRow(credential: credential, isValidating: isValidating &amp;&amp; selectedCredential?.id == credential.id)
                        .tag(credential)
                }
                .onDelete(perform: deleteCredentials)
            }
            .listStyle(.inset)
            
            if let credential = selectedCredential {
                HStack {
                    Button(&quot;Validate&quot;) {
                        validateCredential(credential)
                    }
                    .disabled(isValidating)
                    
                    Button(&quot;Delete&quot;, role: .destructive) {
                        deleteCredential(credential)
                    }
                }
            }
        }
        .sheet(isPresented: $showingAddCredential) {
            AddCredentialSheet()
        }
    }
    
    private func validateCredential(_ credential: CredentialSet) {
        isValidating = true
        
        Task {
            do {
                let account = try await appState.awsService.validateCredentials(credential)
                
                await MainActor.run {
                    if let index = appState.credentials.firstIndex(where: { $0.id == credential.id }) {
                        appState.credentials[index].accountId = account.accountId
                        appState.credentials[index].isValid = true
                        appState.credentials[index].lastValidatedAt = Date()
                    }
                    isValidating = false
                }
                
                // Save updated credential
                try await appState.credentialService.saveCredential(appState.credentials.first { $0.id == credential.id }!)
            } catch {
                await MainActor.run {
                    if let index = appState.credentials.firstIndex(where: { $0.id == credential.id }) {
                        appState.credentials[index].isValid = false
                    }
                    isValidating = false
                    appState.error = AppError(message: &quot;Credential validation failed&quot;, underlying: error)
                }
            }
        }
    }
    
    private func deleteCredential(_ credential: CredentialSet) {
        Task {
            try await appState.credentialService.deleteCredential(id: credential.id)
            await MainActor.run {
                appState.credentials.removeAll { $0.id == credential.id }
                selectedCredential = nil
            }
        }
    }
    
    private func deleteCredentials(at offsets: IndexSet) {
        for index in offsets {
            let credential = appState.credentials[index]
            deleteCredential(credential)
        }
    }
}

struct CredentialRow: View {
    let credential: CredentialSet
    let isValidating: Bool
    
    var body: some View {
        HStack {
            VStack(alignment: .leading, spacing: 4) {
                Text(credential.name)
                    .font(.headline)
                HStack {
                    Text(credential.accessKeyId)
                    Text(&quot;ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¢&quot;)
                    Text(credential.region)
                }
                .font(.caption)
                .foregroundColor(.secondary)
            }
            
            Spacer()
            
            if isValidating {
                ProgressView()
                    .scaleEffect(0.7)
            } else if let isValid = credential.isValid {
                Image(systemName: isValid ? &quot;checkmark.circle.fill&quot; : &quot;xmark.circle.fill&quot;)
                    .foregroundColor(isValid ? .green : .red)
            }
            
            Text(credential.environment.rawValue)
                .font(.caption)
                .padding(.horizontal, 8)
                .padding(.vertical, 4)
                .background(Color.accentColor.opacity(0.1))
                .cornerRadius(4)
        }
        .padding(.vertical, 4)
    }
}

struct AddCredentialSheet: View {
    @EnvironmentObject var appState: AppState
    @Environment(\.dismiss) var dismiss
    
    @State private var name = &quot;&quot;
    @State private var accessKeyId = &quot;&quot;
    @State private var secretAccessKey = &quot;&quot;
    @State private var region = &quot;us-east-1&quot;
    @State private var environment: CredentialEnvironment = .dev
    @State private var isSaving = false
    
    var body: some View {
        VStack(spacing: 20) {
            Text(&quot;Add AWS Credential&quot;)
                .font(.title2)
                .fontWeight(.semibold)
            
            Form {
                TextField(&quot;Name (e.g., &#39;Production AWS&#39;)&quot;, text: $name)
                TextField(&quot;Access Key ID&quot;, text: $accessKeyId)
                SecureField(&quot;Secret Access Key&quot;, text: $secretAccessKey)
                
                Picker(&quot;Region&quot;, selection: $region) {
                    Text(&quot;US East (N. Virginia)&quot;).tag(&quot;us-east-1&quot;)
                    Text(&quot;US West (Oregon)&quot;).tag(&quot;us-west-2&quot;)
                    Text(&quot;Europe (Ireland)&quot;).tag(&quot;eu-west-1&quot;)
                    Text(&quot;Europe (Frankfurt)&quot;).tag(&quot;eu-central-1&quot;)
                    Text(&quot;Asia Pacific (Tokyo)&quot;).tag(&quot;ap-northeast-1&quot;)
                    Text(&quot;Asia Pacific (Singapore)&quot;).tag(&quot;ap-southeast-1&quot;)
                }
                
                Picker(&quot;Environment&quot;, selection: $environment) {
                    ForEach(CredentialEnvironment.allCases, id: \.self) { env in
                        Text(env.rawValue).tag(env)
                    }
                }
            }
            .formStyle(.grouped)
            
            HStack {
                Button(&quot;Cancel&quot;) { dismiss() }
                    .buttonStyle(.bordered)
                
                Button(&quot;Add Credential&quot;) {
                    saveCredential()
                }
                .buttonStyle(.borderedProminent)
                .disabled(!isValid || isSaving)
            }
        }
        .padding()
        .frame(width: 450)
    }
    
    private var isValid: Bool {
        !name.isEmpty &amp;&amp; !accessKeyId.isEmpty &amp;&amp; !secretAccessKey.isEmpty
    }
    
    private func saveCredential() {
        isSaving = true
        
        let credential = CredentialSet(
            id: UUID().uuidString,
            name: name,
            accessKeyId: accessKeyId,
            secretAccessKey: secretAccessKey,
            region: region,
            accountId: nil,
            environment: environment,
            createdAt: Date(),
            lastValidatedAt: nil,
            isValid: nil
        )
        
        Task {
            try await appState.credentialService.saveCredential(credential)
            
            await MainActor.run {
                appState.credentials.append(credential)
                isSaving = false
                dismiss()
            }
        }
    }
}

struct GeneralSettingsView: View {
    @AppStorage(&quot;autoValidateCredentials&quot;) private var autoValidate = true
    @AppStorage(&quot;showAdvancedOptions&quot;) private var showAdvanced = false
    @AppStorage(&quot;defaultTier&quot;) private var defaultTier = 1
    
    var body: some View {
        Form {
            Section {
                Toggle(&quot;Auto-validate credentials on launch&quot;, isOn: $autoValidate)
                Toggle(&quot;Show advanced deployment options&quot;, isOn: $showAdvanced)
            }
            
            Section {
                Picker(&quot;Default Infrastructure Tier&quot;, selection: $defaultTier) {
                    Text(&quot;1 - SEED&quot;).tag(1)
                    Text(&quot;2 - STARTUP&quot;).tag(2)
                    Text(&quot;3 - GROWTH&quot;).tag(3)
                    Text(&quot;4 - SCALE&quot;).tag(4)
                    Text(&quot;5 - ENTERPRISE&quot;).tag(5)
                }
            }
        }
        .formStyle(.grouped)
    }
}

struct AboutView: View {
    var body: some View {
        VStack(spacing: 20) {
            Image(systemName: &quot;cloud.fill&quot;)
                .font(.system(size: 80))
                .foregroundColor(.accentColor)
            
            Text(&quot;RADIANT Deployer&quot;)
                .font(.title)
                .fontWeight(.bold)
            
            Text(&quot;Version 2.2.0&quot;)
                .foregroundColor(.secondary)
            
            Text(&quot;Production-grade multi-tenant AWS SaaS infrastructure deployment and management.&quot;)
                .multilineTextAlignment(.center)
                .foregroundColor(.secondary)
            
            Divider()
            
            VStack(alignment: .leading, spacing: 8) {
                Text(&quot;Features:&quot;)
                    .font(.headline)
                
                FeatureRow(icon: &quot;server.rack&quot;, text: &quot;Multi-environment deployment (Dev/Staging/Prod)&quot;)
                FeatureRow(icon: &quot;cpu&quot;, text: &quot;20+ AI providers, 30+ self-hosted models&quot;)
                FeatureRow(icon: &quot;lock.shield&quot;, text: &quot;HIPAA &amp; SOC 2 compliance&quot;)
                FeatureRow(icon: &quot;person.2&quot;, text: &quot;Two-person approval for production&quot;)
                FeatureRow(icon: &quot;globe&quot;, text: &quot;Multi-region global deployment&quot;)
            }
            
            Spacer()
            
            Text(&quot;Ãƒâ€šÃ‚Â© 2024 Zynapses Inc.&quot;)
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .padding()
    }
}

struct FeatureRow: View {
    let icon: String
    let text: String
    
    var body: some View {
        HStack {
            Image(systemName: icon)
                .foregroundColor(.accentColor)
                .frame(width: 20)
            Text(text)
        }
    }
}</code></pre>
<h3 id="radiantdeployerviewsprovidersview.swift">RadiantDeployer/Views/ProvidersView.swift</h3>
<pre class="swift"><code>import SwiftUI

struct ProvidersView: View {
    @EnvironmentObject var appState: AppState
    
    var body: some View {
        VStack {
            Text(&quot;AI Providers&quot;)
                .font(.title)
            Text(&quot;Provider management is available in the Admin Dashboard after deployment.&quot;)
                .foregroundColor(.secondary)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .navigationTitle(&quot;Providers&quot;)
    }
}</code></pre>
<h3 id="radiantdeployerviewsmodelsview.swift">RadiantDeployer/Views/ModelsView.swift</h3>
<pre class="swift"><code>import SwiftUI

struct ModelsView: View {
    @EnvironmentObject var appState: AppState
    
    var body: some View {
        VStack {
            Text(&quot;AI Models&quot;)
                .font(.title)
            Text(&quot;Model management is available in the Admin Dashboard after deployment.&quot;)
                .foregroundColor(.secondary)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .navigationTitle(&quot;Models&quot;)
    }
}</code></pre>
<hr />
<h2 id="part-5-bundle-scripts">PART 5: BUNDLE SCRIPTS</h2>
<h3 id="toolsscriptsbundle-infrastructure.sh">tools/scripts/bundle-infrastructure.sh</h3>
<pre class="bash"><code>#!/bin/bash
set -e

echo &quot;=== RADIANT Infrastructure Bundler ===&quot;

# Paths
SCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;
ROOT_DIR=&quot;$(cd &quot;$SCRIPT_DIR/../..&quot; &amp;&amp; pwd)&quot;
INFRA_SOURCE=&quot;$ROOT_DIR/packages/infrastructure&quot;
SWIFT_APP=&quot;$ROOT_DIR/apps/swift-deployer&quot;
BUNDLE_TARGET=&quot;$SWIFT_APP/Resources/Infrastructure&quot;

echo &quot;Source: $INFRA_SOURCE&quot;
echo &quot;Target: $BUNDLE_TARGET&quot;

# Clean and create target
rm -rf &quot;$BUNDLE_TARGET&quot;
mkdir -p &quot;$BUNDLE_TARGET&quot;

# Copy CDK source
echo &quot;Copying CDK source...&quot;
cp -R &quot;$INFRA_SOURCE/bin&quot; &quot;$BUNDLE_TARGET/&quot;
cp -R &quot;$INFRA_SOURCE/lib&quot; &quot;$BUNDLE_TARGET/&quot;
cp -R &quot;$INFRA_SOURCE/lambda&quot; &quot;$BUNDLE_TARGET/&quot;
cp &quot;$INFRA_SOURCE/package.json&quot; &quot;$BUNDLE_TARGET/&quot;
cp &quot;$INFRA_SOURCE/package-lock.json&quot; &quot;$BUNDLE_TARGET/&quot; 2&gt;/dev/null || true
cp &quot;$INFRA_SOURCE/cdk.json&quot; &quot;$BUNDLE_TARGET/&quot;
cp &quot;$INFRA_SOURCE/tsconfig.json&quot; &quot;$BUNDLE_TARGET/&quot;

# Copy migrations
if [ -d &quot;$ROOT_DIR/migrations&quot; ]; then
    echo &quot;Copying migrations...&quot;
    cp -R &quot;$ROOT_DIR/migrations&quot; &quot;$BUNDLE_TARGET/&quot;
fi

# Install production dependencies
echo &quot;Installing production dependencies...&quot;
cd &quot;$BUNDLE_TARGET&quot;
npm ci --production

echo &quot;=== Bundle complete ===&quot;
echo &quot;Size: $(du -sh &quot;$BUNDLE_TARGET&quot; | cut -f1)&quot;</code></pre>
<h3 id="toolsscriptsbundle-node.sh">tools/scripts/bundle-node.sh</h3>
<pre class="bash"><code>#!/bin/bash
set -e

echo &quot;=== Node.js Runtime Bundler ===&quot;

# Paths
SCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;
SWIFT_APP=&quot;$(cd &quot;$SCRIPT_DIR/../../apps/swift-deployer&quot; &amp;&amp; pwd)&quot;
NODE_TARGET=&quot;$SWIFT_APP/Resources/NodeRuntime&quot;

# Node version
NODE_VERSION=&quot;20.10.0&quot;

echo &quot;Target: $NODE_TARGET&quot;
echo &quot;Node Version: $NODE_VERSION&quot;

# Clean and create target
rm -rf &quot;$NODE_TARGET&quot;
mkdir -p &quot;$NODE_TARGET&quot;

# Download Node.js for macOS ARM64
ARCH=$(uname -m)
if [ &quot;$ARCH&quot; = &quot;arm64&quot; ]; then
    NODE_ARCH=&quot;arm64&quot;
else
    NODE_ARCH=&quot;x64&quot;
fi

NODE_URL=&quot;https://nodejs.org/dist/v${NODE_VERSION}/node-v${NODE_VERSION}-darwin-${NODE_ARCH}.tar.gz&quot;
TEMP_DIR=$(mktemp -d)

echo &quot;Downloading Node.js...&quot;
curl -sL &quot;$NODE_URL&quot; | tar xz -C &quot;$TEMP_DIR&quot;

# Copy only necessary files
echo &quot;Copying runtime...&quot;
cp -R &quot;$TEMP_DIR/node-v${NODE_VERSION}-darwin-${NODE_ARCH}/bin&quot; &quot;$NODE_TARGET/&quot;
cp -R &quot;$TEMP_DIR/node-v${NODE_VERSION}-darwin-${NODE_ARCH}/lib&quot; &quot;$NODE_TARGET/&quot;

# Cleanup
rm -rf &quot;$TEMP_DIR&quot;

echo &quot;=== Bundle complete ===&quot;
echo &quot;Size: $(du -sh &quot;$NODE_TARGET&quot; | cut -f1)&quot;</code></pre>
<hr />
<h2 id="build-instructions">BUILD INSTRUCTIONS</h2>
<ol type="1">
<li><p><strong>Build Shared Package</strong>:</p>
<pre class="bash"><code>cd packages/shared
npm install
npm run build</code></pre></li>
<li><p><strong>Bundle Node.js Runtime</strong>:</p>
<pre class="bash"><code>chmod +x tools/scripts/bundle-node.sh
./tools/scripts/bundle-node.sh</code></pre></li>
<li><p><strong>Bundle Infrastructure</strong> (after completing Prompts 2-3):</p>
<pre class="bash"><code>chmod +x tools/scripts/bundle-infrastructure.sh
./tools/scripts/bundle-infrastructure.sh</code></pre></li>
<li><p><strong>Open in Xcode</strong>:</p>
<pre class="bash"><code>cd apps/swift-deployer
open RadiantDeployer.xcodeproj</code></pre></li>
<li><p><strong>Build and Run</strong>:</p>
<ul>
<li>Select â€œMy Macâ€ as the destination</li>
<li>Press ÃƒÂ¢Ã…â€™Ã‹Å“R to build and run</li>
</ul></li>
</ol>
<hr />
<h2 id="dependencies">DEPENDENCIES</h2>
<h3 id="swift-add-to-xcode-project">Swift (Add to Xcode Project)</h3>
<ul>
<li>SQLite3 (System framework)</li>
<li>Security (System framework)</li>
</ul>
<h3 id="node.js-bundled">Node.js (bundled)</h3>
<ul>
<li>aws-cdk: ^2.120.0</li>
<li>aws-cdk-lib: ^2.120.0</li>
<li>constructs: ^10.3.0</li>
</ul>
<hr />
<h2 id="next-prompts">NEXT PROMPTS</h2>
<p>Continue with: - <strong>Prompt 2</strong>: CDK Infrastructure Stacks (VPC, Database, Security, Storage) - <strong>Prompt 3</strong>: CDK AI &amp; API Stacks (LiteLLM, SageMaker, API Gateway) - <strong>Prompt 4</strong>: Lambda Functions - Core - <strong>Prompt 5</strong>: Lambda Functions - Admin &amp; Billing - <strong>Prompt 6</strong>: Self-Hosted Models &amp; Mid-Level Services - <strong>Prompt 7</strong>: External Providers &amp; Database Schema - <strong>Prompt 8</strong>: Admin Web Dashboard - <strong>Prompt 9</strong>: Assembly &amp; Deployment Guide</p>
<hr />
<p><em>End of Prompt 1: Foundation &amp; Swift Deployment App</em> <em>RADIANT v2.2.0 - December 2024</em></p>
<h1 id="Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢-1">Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â</h1>
<h1 id="end-of-section-1">END OF SECTION 1</h1>
<h1 id="Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢-2">Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â</h1>
<h1 id="Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢Ã¢-3">Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â</h1>

  
  <div class="footer">
    RADIANT Documentation | Version 5.52.29 | Generated January 25, 2026
  </div>
</body>
</html>